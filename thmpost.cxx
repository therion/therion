/**
 * @file thmpost.cxx
 *
 * THIS FILE IS GENERATED AUTOMATICALLY, DO NOT MODIFY IT !!!
 */  
 
#include "thmpost.h"

#ifndef THMSVC

const char * thmpost_library = 
"%% therion source code\n"
"%%\n"
"%% therion.mp\n"
"%%\n"
"%% This file defines low-level MetaPost macros and variables required\n"
"%% for generation of map symbols\n"
"%%\n"
"%% $Date: 2003/07/01 09:06:44 $\n"
"%% $RCSfile: therion.mp,v $\n"
"%% $Revision: 1.3 $\n"
"%%\n"
"%% Copyright (C) 2000-2003 Martin Budaj\n"
"%%\n"
"%% Some macros are adapted from MPATTERN package of P. Bolek\n"
"%%\n"
"%% Some macros are used from MetaFun package of H. Hagen\n"
"%%\n"
"%% -------------------------------------------------------------------- \n"
"%% This program is free software; you can redistribute it and/or modify\n"
"%% it under the terms of the GNU General Public License as published by\n"
"%% the Free Software Foundation; either version 2 of the License, or\n"
"%% any later version.\n"
"%%\n"
"%% This program is distributed in the hope that it will be useful,\n"
"%% but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
"%% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n"
"%% GNU General Public License for more details.\n"
"%% \n"
"%% You should have received a copy of the GNU General Public License\n"
"%% along with this program; if not, write to the Free Software\n"
"%% Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n"
"%% --------------------------------------------------------------------\n"
"\n"
"%    This file defines low level macros used for map signatures in Therion.\n"
"%    Before loading this file set `Scale' variable to numeric value\n"
"%    representing denominator of the scale ratio. Internal variable \n"
"%    `prologues' is set to 1 by this file. This module loads also \n"
"%    symbol libraries.\n"
"\n"
"\n"
"tracingstats:=1;\n"
"prologues:=0;\n"
"\n"
"if known Background: background:=Background fi;\n"
"%TrueScale:=Scale;\n"
"\n"
"% @VARIABLE\n"
"% symbol_scale --\n"
"%\n"
"% <I>internal numeric</I>; in map symbol definitions used for scaling\n"
"% in <A HREF=\"#T\">T</A> transformation; recommended\n"
"% values are 1 or 2.\n"
"\n"
"%newinternal symbol_scale;\n"
"%symbol_scale := 1;\n"
"\n"
"% @VARIABLE\n"
"% fill_only --\n"
"%\n"
"% <I>boolean</I>, used in <A HREF=\"#thdraw\">thdraw</A> and\n"
"% <A HREF=\"#thpattfill\">thpattfill</A> commands. When set to false, it has \n"
"% no effect, when it is true, it supresses all drawing \n"
"% commands with exception of <I>thpermanentfill</I>, so that only filled \n"
"% areas are drawn\n"
"\n"
"boolean fill_only, horiz_labels, transparency;\n"
"fill_only := false;\n"
"horiz_labels:=true;\n"
"transparency:=false;\n"
"\n"
"string ATTR__id, ATTR__survey, ATTR__scrap, NorthDir;\n"
"boolean ATTR__scrap_centerline;\n"
"picture ATTR__text;\n"
"numeric ATTR__height;\n"
"boolean ATTR__elevation;\n"
"ATTR__scrap_centerline := false;\n"
"ATTR__height:=0;\n"
"ATTR__elevation:=false;\n"
"\n"
"boolean ATTR__shotflag_splay;\n"
"ATTR__shotflag_splay:=false;\n"
"boolean ATTR__shotflag_duplicate;\n"
"ATTR__shotflag_duplicate:=false;\n"
"boolean ATTR__shotflag_approx;\n"
"ATTR__shotflag_approx:=false;\n"
"boolean ATTR__stationflag_splay;\n"
"ATTR__stationflag_splay:=false;\n"
"\n"
"\n"
"color label_fill_color, label_fill_color_tmp;\n"
"label_fill_color := (1.0, 1.0, 1.0);\n"
"def push_label_fill_color(expr r,g,b) =\n"
"  label_fill_color_tmp := label_fill_color;\n"
"  label_fill_color := (r,g,b);\n"
"enddef;\n"
"def pop_label_fill_color =\n"
"  label_fill_color := label_fill_color_tmp;\n"
"enddef;\n"
"def process_filledlabel(expr cent, rot) =\n"
"  begingroup;\n"
"    interim bboxmargin:=2.0bp;\n"
"    q:=((bbox lab) smoothed 2) rotatedaround (cent, rot);\n"
"    fill q withcolor label_fill_color;\n"
"    draw lab rotatedaround (cent, rot);\n"
"    write_circ_bbox(q);  % without corners smoothing it was enough to use\n"
"                         % write_bbox(q);\n"
"  endgroup;\n"
"enddef;\n"
"\n"
"\n"
"\n"
"\n"
"numeric area_border_errors;\n"
"area_border_errors = 0;\n"
"\n"
"% @VARIABLE\n"
"% last_write --\n"
"%\n"
"% <I>numeric</I>; charcode of last figure which contained \n"
"% <A HREF=\"#write_bbox\">write_bbox</A> macro; this value is used by\n"
"% <A HREF=\"#close_file\">close_file</A> macro. Initially set to -1.\n"
"\n"
"numeric last_write;\n"
"last_write = -1;\n"
"\n"
"% @VARIABLE\n"
"% strut_string --\n"
"%\n"
"% <I>string</I> containing combination of the \"highest\" and \"lowest\" character\n"
"% in used font; it's used by <A HREF=\"\">free_text</A> macro.\n"
"\n"
"%string strut_string;\n"
"%strut_string = \"(È\";\n"
"\n"
"% @VARIABLE\n"
"% file_name --\n"
"%\n"
"% <I>string</I>, name of file, where <I>write_bbox</I> macro writes\n"
"% text clipping path\n"
"\n"
"% @VARIABLE\n"
"% s ch --\n"
"%\n"
"% <I>string</I>, temporary string/char variables\n"
"\n"
"string s, ch, file_name, bg_name, clip_name, lang, diff_pos, diff_neg,\n"
"     current_scrap, current_src;\n"
"\n"
"% @VARIABLE\n"
"% u v w --\n"
"%\n"
"% <I>internal numeric variables</I> used as basic length units for drawing;\n"
"% they are set by <A HREF=\"#initialize\">initialize</A> macro.\n"
"% <UL> <LI><I>u</I> -- normal unit decreasing with increasing scale\n"
"%      <LI><I>v</I> -- like <I>u</I>, but can increase drammaticaly\n"
"%            when some limit is encountered (to get effects like logarithmic\n"
"%            scale)\n"
"%      <LI><I>w</I> -- nearly constant at all scales\n"
"% </UL>\n"
"\n"
"% @VARIABLE\n"
"% legend_scale --\n"
"%\n"
"% <I>numeric</I>, length of the longer side of signatures' legend box\n"
"\n"
"newinternal legend_scale, u,v,w;\n"
"\n"
"% @VARIABLE\n"
"% lab Lab --\n"
"%\n"
"% <I>picture</I>, in which are saved typeset labels\n"
"\n"
"picture lab, Lab;\n"
"\n"
"% @VARIABLE\n"
"% T --\n"
"%\n"
"% <I>transformation</I>, defines transformation function for transforming \n"
"% every argument of <A HREF=\"#thdraw>thdraw</A> and <A HREF=\"#thfill>thfill</A>\n"
"% macros\n"
"\n"
"transform T;\n"
"\n"
"% @VARIABLE\n"
"% p,q --\n"
"%\n"
"% <I>path</I>, for saving temporary paths\n"
"\n"
"path p,q;\n"
"\n"
"% @MACRO\n"
"% initialize --\n"
"%\n"
"% initializes basic length units <A HREF=\"#u\">(u,v,w)</A> and pens used \n"
"% in map symbols according to scale. Five circular pens are defined:\n"
"% <UL><LI>PenA -- thick; for outlines\n"
"%    <LI>PenB, PenC -- thinner; for pits, symbols etc.\n"
"%    <LI>PenD -- thinnest; for fine details\n"
"%    <LI>PenX -- extra thick; not recommended for use\n"
"% </UL>\n"
"\n"
"def fonts_setup (expr t,s,m,l,h) =\n"
"  write \"\\def\\updown#1#2{\\vbox{\" &\n"
"        \"\\offinterlineskip\" &\n"
"        \"\\setbox100=\\hbox{#1}\" &\n"
"        \"\\setbox101=\\hbox{#2}\" &\n"
"        \"\\ifnum\\wd100>\\wd101\\hsize=\\wd100\\else\\hsize=\\wd101\\fi\" &\n"
"        \"\\centerline{\\box100}\\vskip4pt\" &\n"
"        \"\\centerline{\\box101}}}\" &\n"
"        \"\\def\\thlabel{\\thnormalsize}\" &\n"
"        \"\\def\\thremark{\\thsmallsize\\si}\" &\n"
"        \"\\def\\thcomment{\\thsmallsize}\" &\n"
"        \"\\def\\thentrance{\\thsmallsize}\" &\n"
"        \"\\def\\thaltitude{\\thsmallsize}\" &\n"
"        \"\\def\\thstationname{\\thsmallsize}\" &\n"
"        \"\\def\\thdate{\\thsmallsize}\" &\n"
"        \"\\def\\thheight{\\thsmallsize}\" &\n"
"        \"\\def\\thheightpos{+\\ignorespaces}\" &\n"
"        \"\\def\\thheightneg{-\\ignorespaces}\" &\n"
"        \"\\def\\thframed{\\thsmallsize}\" &\n"
"        \"\\def\\thwallaltitude{\\thtinysize}\"\n"
"  to \"mptexpre.tex\";\n"
"  write \"\\def\\thtinysize{\\size[\" & decimal max(optical_zoom*t,0) & \"]}\" & \n"
"        \"\\def\\thsmallsize{\\size[\" & decimal max(optical_zoom*s,0) & \"]}\" & \n"
"        \"\\def\\thnormalsize{\\size[\" & decimal max(optical_zoom*m,0) & \"]}\" & \n"
"        \"\\def\\thlargesize{\\size[\" & decimal max(optical_zoom*l,0) & \"]}\" & \n"
"        \"\\def\\thhugesize{\\size[\" & decimal max(optical_zoom*h,0) & \"]}\" \n"
"  to \"mptexpre.tex\";\n"
"  write EOF to \"mptexpre.tex\";\n"
"enddef;\n"
"\n"
"def initialize (expr sc) =\n"
"\n"
"  if unknown BaseScale: BaseScale = sc; fi;\n"
"  optical_zoom := BaseScale/sc;\n"
"\n"
"    if BaseScale <= 1:                   % 1:100\n"
"        u:=14bp; v:=14bp; w:=12bp;\n"
"        fonts_setup(8,10,12,16,24);\n"
"    elseif BaseScale <= 2:               % 1:200\n"
"        u:=12bp; v:=12bp; w:=12bp;\n"
"        fonts_setup(7,8,10,14,20);\n"
"    elseif BaseScale <= 5:               % 1:500\n"
"        u:=10bp; v:=10bp; w:=12bp;\n"
"        fonts_setup(6,7,8,10,14);\n"
"    else:\n"
"        u:=7bp; v:=14bp; w:=10bp;\n"
"        fonts_setup(5,6,7,8,10);\n"
"    fi;\n"
"    \n"
"    u := optical_zoom * u;\n"
"    v := optical_zoom * v;\n"
"    w := optical_zoom * w;\n"
"\n"
"    defaultscale := 0.8 * optical_zoom;\n"
"\n"
"    def PenA = pencircle scaled (u/10) enddef;\n"
"    def PenB = pencircle scaled (0.7*u/10) enddef;\n"
"    def PenC = pencircle scaled (0.5*u/10) enddef;\n"
"    def PenD = pencircle scaled (0.35*u/10) enddef;\n"
"    def PenX = pencircle scaled (1.2*u/10) enddef;\n"
"    \n"
"    legend_scale := 3.14*u;\n"
"enddef;\n"
"\n"
"% macro is expanded, we have to know all dimensions and pens before reading\n"
"% mpattern macros\n"
"\n"
"initialize(Scale);\n"
"\n"
"vardef thTEX primary s =\n"
"  write \"verbatimtex \\input th_enc.tex etex\" to \"mptextmp.mp\";\n"
"  write \"btex \\mainfont \"&s&\" etex\" to \"mptextmp.mp\";\n"
"  write EOF to \"mptextmp.mp\";\n"
"  scantokens \"input mptextmp\"\n"
"enddef;\n"
"\n"
"% @MACRO\n"
"% inscale --\n"
"%\n"
"% zooms objects to scale specified in legend_scale variable (used in legend\n"
"% typesetting)\n"
"\n"
"def inscale = \n"
"    xscaled legend_scale yscaled (0.618*legend_scale)\n"
"enddef;\n"
"\n"
"% @MACRO\n"
"% draw_legend_box --\n"
"%\n"
"% draws a legend bounding box and resets drawoptions() options \n"
"\n"
"def draw_legend_box =\n"
"    clip currentpicture to unitsquare inscale;\n"
"    drawoptions();\n"
"    pickup PenB;\n"
"    draw unitsquare inscale;\n"
"enddef;\n"
"\n"
"def clean_legend_box =\n"
"  unfill unitsquare inscale;\n"
"enddef;\n"
"\n"
"def legend_point (expr name) =\n"
"%  if substring (2,9) of name = \"station\":\n"
"%    scantokens(name)((0.5,0.5) inscale);\n"
"%  else:\n"
"    scantokens(name)((0.5,0.5) inscale,0,1,(0,0));\n"
"%  fi;\n"
"  draw_legend_box;\n"
"enddef;\n"
"\n"
"def legend_line (expr name) =\n"
"  scantokens(name)((((-0.3,.5)..(.3,.7)..(.5,.3)..{dir 80}(1.3,.9)) inscale) \n"
"                randomized 3mm);\n"
"  draw_legend_box;\n"
"enddef;\n"
"\n"
"% legend_label\n"
"% legend_area\n"
"% legend_random\n"
"\n"
"% @MACRO\n"
"% roundone --\n"
"%\n"
"% rounds <I>numeric value</I> to one decimal point\n"
"\n"
"vardef roundone(expr n) =\n"
"%    round(10*n)/10\n"
"  n\n"
"enddef;\n"
"\n"
"% @MACRO\n"
"% process_label --\n"
"%\n"
"% draws a label saved in <I>lab</I> picture variable and calls \n"
"% <A HREF=\"#write_bbox\">write_bbox</A> macro.\n"
"\n"
"\n"
"def process_label (expr cent, rot) =\n"
"  begingroup;\n"
"    interim bboxmargin:=0.8bp;\n"
"    q:=((bbox lab) smoothed 2) rotatedaround (cent, rot);\n"
"    draw lab rotatedaround (cent, rot);\n"
"    write_circ_bbox(q);  % without corners smoothing it was enough to use\n"
"                         % write_bbox(q);\n"
"  endgroup;\n"
"enddef;\n"
"\n"
"% @MACRO\n"
"% process_uplabel --\n"
"%\n"
"% draws a label into semicircular box and writes clipping path to a file\n"
"\n"
"def process_uplabel =\n"
"  begingroup;\n"
"    interim bboxmargin := 0.8 bp;\n"
"    q:=bbox lab;\n"
"  endgroup;\n"
"    alef:=.8-.02*(xpart lrcorner q - xpart llcorner q);\n"
"%    show alef;\n"
"    q:=alef[llcorner q,ulcorner q]{up} .. {down}alef[lrcorner q, urcorner q] --\n"
"        lrcorner q -- llcorner q -- cycle;\n"
"    draw lab;\n"
"    draw q;\n"
"    q:=reverse q;\n"
"    write_circ_bbox(q);\n"
"enddef;\n"
"\n"
"% @MACRO\n"
"% process_downlabel --\n"
"%\n"
"% draws a label into down oriented semicircular box and writes\n"
"% clipping path to a file\n"
"\n"
"def process_downlabel =\n"
"  begingroup;\n"
"    interim bboxmargin := 0.8 bp;\n"
"    q:=bbox lab;\n"
"  endgroup;\n"
"    alef:=1-(.8-.02*(xpart lrcorner q - xpart llcorner q));\n"
"    q:=alef[llcorner q,ulcorner q]{down} .. \n"
"        {up}alef[lrcorner q, urcorner q] --\n"
"        urcorner q -- ulcorner q -- cycle;\n"
"    draw lab;\n"
"    draw q;\n"
"    write_circ_bbox(q);\n"
"enddef;\n"
"\n"
"% @MACRO\n"
"% process_updownlabel --\n"
"%\n"
"% draws a label splitted into down and up oriented semicircular boxes and \n"
"% writes clipping path to a file\n"
"\n"
"def process_updownlabel =\n"
"  begingroup;\n"
"    interim bboxmargin := 0.8 bp;\n"
"    p:=bbox lab;\n"
"  endgroup;\n"
"    leftside:=xpart llcorner p;\n"
"    rightside:=xpart lrcorner p;\n"
"    draw (xpart llcorner p,.5[ypart llcorner p,ypart ulcorner p]) -- \n"
"         (xpart lrcorner p,.5[ypart llcorner p,ypart ulcorner p]);\n"
"    alef:=1.05-.02*(xpart lrcorner p - xpart llcorner p);\n"
"%    alef:=.8-.02*(rightside-leftside);\n"
"    p:=alef[(leftside, ypart llcorner p),(leftside, ypart ulcorner p)]{up} .. \n"
"       {down}alef[(rightside, ypart lrcorner p), (rightside, ypart urcorner p)]\n"
"        -- alef[(rightside, ypart urcorner p), (rightside, ypart lrcorner p)]{down}\n"
"        .. {up}alef[(leftside, ypart ulcorner p),(leftside, ypart llcorner p)]\n"
"        -- cycle;\n"
"%    p:=alef[llcorner p,ulcorner p]{up} .. {down}alef[lrcorner p, urcorner p] --\n"
"%        aleff[llcorner p,ulcorner p]{down} .. \n"
"%        {up}aleff[lrcorner p, urcorner p] -- cycle;\n"
"    draw lab;\n"
"    draw p;\n"
"    p:=reverse p;\n"
"    write_circ_bbox(p);\n"
"enddef;\n"
"\n"
"def process_updownlabel_OLD =\n"
"    p:=bbox lab;\n"
"    q:=bbox Lab;\n"
"    leftside:=min(xpart llcorner p, xpart ulcorner q);\n"
"    rightside:=max(xpart lrcorner p, xpart urcorner q);\n"
"    draw .5[(leftside, ypart llcorner p),(leftside, ypart ulcorner q)] -- \n"
"         .5[(rightside,ypart lrcorner p),(rightside,ypart urcorner q)];\n"
"    alef:=.8-.02*(rightside-leftside);\n"
"    q:=alef[(leftside, ypart llcorner p),(leftside, ypart ulcorner p)]{up} .. \n"
"       {down}alef[(rightside, ypart lrcorner p), (rightside, ypart urcorner p)]\n"
"        -- alef[(rightside, ypart urcorner q), (rightside, ypart lrcorner q)]{down}\n"
"        .. {up}alef[(leftside, ypart ulcorner q),(leftside, ypart llcorner q)]\n"
"        -- cycle;\n"
"    draw lab;\n"
"    draw Lab;\n"
"    draw q;\n"
"    q:=reverse q;\n"
"    write_circ_bbox(q);\n"
"enddef;\n"
"\n"
"% @MACRO\n"
"% process_boxedlabel --\n"
"%\n"
"% draws a label into circular box and writes\n"
"% clipping path to a file\n"
"\n"
"def process_boxedlabel =\n"
"    q:=bbox lab;\n"
"    draw lab;\n"
"    draw q;\n"
"    write_bbox(q);\n"
"enddef;\n"
"\n"
"% @MACRO\n"
"% process_circledlabel --\n"
"%\n"
"% draws a label into circular box and writes\n"
"% clipping path to a file\n"
"\n"
"def process_circledlabel =\n"
"  begingroup;\n"
"    interim bboxmargin := 0.4 bp;\n"
"    q:=bbox lab;\n"
"  endgroup;\n"
"    q:=point 0 of q .. point 1 of q .. point 2 of q .. point 3 of q .. cycle;\n"
"    draw lab;\n"
"    draw q;\n"
"    write_circ_bbox(q);\n"
"enddef;\n"
"\n"
"\n"
"% @MACRO\n"
"% write_bbox --\n"
"%\n"
"% Arguments:\n"
"%   <I>path</I> variable -- rectangular bounding box of a label;\n"
"%   assumptions: path is cyclic, counterclockwise oriented, with four points,\n"
"%   composed from linear segments;\n"
"%   see general <A HREF=\"#write_circ_bbox\">write_circ_bbox</A> macro\n"
"% Results:\n"
"%   one file per figure which uses labels with a clipping path in pseudo-pdf \n"
"%   format\n"
"\n"
"def write_bbox (expr q) =\n"
"    file_name := jobname & \".\" & decimal(charcode) & \"bbox\";\n"
"    for i:=4 downto 0:\n"
"        s  :=  decimal(roundone(xpart point i of q)) & \" \" \n"
"             & decimal(roundone(ypart point i of q)) \n"
"             & if i=4: \" m \" else: \" l\" fi;\n"
"        write s to file_name;\n"
"    endfor;\n"
"    last_write := charcode;\n"
"enddef;\n"
"\n"
"% @MACRO\n"
"% write_circ_bbox --\n"
"%\n"
"% Arguments:\n"
"%   <I>path</I> variable, only assumption is that <I>path</I> is cyclic\n"
"%   and counterclockwise oriented.\n"
"% Results:\n"
"%   one file per figure which uses labels with a clipping path in pseudo-pdf \n"
"%   format\n"
"\n"
"def write_circ_bbox expr q =\n"
"    file_name := jobname & \".\" & decimal(charcode) & \"bbox\";\n"
"    tmp:=length q;\n"
"    s :=  decimal(roundone(xpart point tmp of q)) & \" \" \n"
"             & decimal(roundone(ypart point tmp of q)) & \" m\";\n"
"    write s to file_name;\n"
"    for i:=tmp downto 1:\n"
"        s :=  decimal(roundone(xpart precontrol i of q)) & \" \" \n"
"             & decimal(roundone(ypart precontrol i of q)) & \" \"\n"
"             & decimal(roundone(xpart postcontrol i-1 of q)) & \" \" \n"
"             & decimal(roundone(ypart postcontrol i-1 of q)) & \" \"\n"
"             & decimal(roundone(xpart point i-1 of q)) & \" \" \n"
"             & decimal(roundone(ypart point i-1 of q)) & \" c\";\n"
"        write s to file_name;\n"
"    endfor;\n"
"    last_write := charcode;\n"
"enddef;\n"
"\n"
"% @MACRO\n"
"% close_file --\n"
"%\n"
"% closes file with a clipping path; it's invoked by <I>endchar</I> macro\n"
"\n"
"def close_file =\n"
"    if last_write=charcode:\n"
"        write EOF to jobname & \".\" & decimal(charcode) & \"bbox\";\n"
"    fi;\n"
"enddef;\n"
"\n"
"% endchar should run close_file macro\n"
"\n"
"extra_endfig := \"close_file;\";\n"
"\n"
"% @MACRO\n"
"% thdraw --\n"
"%\n"
"% like plain MetaPost's <I>draw</I>, but draws a <I>path</I> transformed\n"
"% (rotated, scaled, shifted) to scrap's coordinates according T variable.\n"
"% (If <I>fill_only=false</I>)\n"
"\n"
"def thdrawoptions(text t) =\n"
"  def _thop_ = t enddef\n"
"enddef;\n"
"thdrawoptions();\n"
"\n"
"def thdraw expr p = \n"
"  if not fill_only:\n"
"    addto currentpicture \n"
"    if picture p: \n"
"      also (p transformed T)\n"
"    else:\n"
"      doublepath (p transformed T) withpen currentpen \n"
"    fi  \n"
"    _thop_  _op_\n"
"  else:\n"
"    addto currentpicture also nullpicture\n"
"  fi\n"
"enddef;\n"
"\n"
"% @MACRO\n"
"% thfill --\n"
"%\n"
"% fills a <I>path</I> transformed\n"
"% (rotated, scaled, shifted) to scrap's coordinates according T variable.\n"
"% Filled areas are clipped (like most \n"
"% other lines and points) with a clipping path around text labels.\n"
"\n"
"\n"
"def thfill expr c = \n"
"    addto currentpicture contour (c transformed T) _thop_ _op_ \n"
"enddef;\n"
"\n"
"def thfilldraw expr c =\n"
"  if not fill_only:\n"
"    addto currentpicture contour (c transformed T) withpen currentpen _thop_ _op_ \n"
"  else:\n"
"    addto currentpicture contour (c transformed T) _thop_ _op_ \n"
"  fi\n"
"enddef;\n"
"\n"
"def thunfill expr c = \n"
"    thfill c withcolor background \n"
"enddef;\n"
"\n"
"def thundraw expr p = \n"
"    thdraw p withcolor background \n"
"enddef;\n"
"\n"
"def thunfilldraw expr c = \n"
"    thfilldraw c withcolor background \n"
"enddef;\n"
"\n"
"def thclean expr c =\n"
"  if transparency:\n"
"    thfill c withtransparentcolor tr_bg\n"
"  else:\n"
"    thunfill c\n"
"  fi;\n"
"enddef;\n"
"\n"
"def thPatternFill (expr Path, Pattern) =\n"
"  T:=identity;\n"
"  thclean Path;\n"
"  thfill Path withpattern Pattern;\n"
"enddef;\n"
"\n"
"%def thLegendPatternFill (expr Path, Pattern) =\n"
"%  T:=identity;\n"
"%  thfill Path withpattern Pattern;\n"
"%enddef;\n"
"\n"
"% for drawarrow:\n"
"\n"
"def _finarr text t =\n"
"  thdraw _apth t;\n"
"  thfilldraw arrowhead _apth  t\n"
"enddef;\n"
"\n"
"% @MACRO\n"
"% thpermanentfill --\n"
"%\n"
"% Fills specified area with a solid color; this area is not affected by \n"
"% text clipping path\n"
"\n"
"%def thpermanentfill expr c = \n"
"%    addto currentpicture contour (c transformed T) _thop_ _op_\n"
"%enddef;\n"
"\n"
"let thpermanentfill = thfill;\n"
"\n"
"\n"
"primarydef p aligned al=\n"
"  p shifted (xpart al * xpart U, ypart al * ypart U)\n"
"enddef;\n"
"\n"
"% macros for drawing scraps in upper and lower levels; filled lower scraps \n"
"% require special treatment (MetaPost doesn't support non-continuous paths).\n"
"% We can't use one file for both, while PDF XObject has to be explicitely \n"
"% filled or stroked. Second macro writes also pseudo-pdf code of a clipping \n"
"% path for given scrap\n"
"\n"
"boolean drawnext;\n"
"drawnext:=true;\n"
"\n"
"def draw_upscrap (expr isout)(text t) =\n"
"  path q;\n"
"  for i=t:\n"
"    if (numeric i):\n"
"      if (i=1): drawnext:=true; else: drawnext:=false; fi;\n"
"    else:\n"
"      if drawnext: draw i withpen PenD; fi;\n"
"      if not known q: q:=i; else: q:=q -- i; fi;\n"
"    fi;\n"
"  endfor;\n"
"  if not cycle q: q:=q -- cycle; fi;\n"
"  if turningnumber q = 0: \n"
"      thwarning(\"scrap outline intersects itself\"); \n"
"  fi;\n"
"  if isout=1:\n"
"    if turningnumber q > 0: q := reverse q; fi;\n"
"  else:\n"
"    if turningnumber q < 0: q := reverse q; fi;\n"
"  fi;\n"
"  addto bgfill contour q;\n"
"enddef;\n"
"\n"
"% following macro writes noncontinuous PostScript path directly to EPS file\n"
"% (filled background and clipping path)\n"
"\n"
"picture bgfill;\n"
"bgfill:=nullpicture;\n"
"\n"
"def draw_downscrap =\n"
"  bg_name := jobname & \".\" & decimal(charcode) & \"bg\";\n"
"  clip_name := jobname & \".\" & decimal(charcode) & \"clip\";\n"
"  write \"%!PS\" to bg_name;\n"
"  write \"%%BoundingBox: \" & \n"
"     decimal floor xpart llcorner bgfill & \" \" &\n"
"     decimal floor ypart llcorner bgfill & \" \" &\n"
"     decimal ceiling xpart urcorner bgfill & \" \" &\n"
"     decimal ceiling ypart urcorner bgfill \n"
"     to bg_name;\n"
"  write \"%%Page: 1 1\" to bg_name;\n"
"  write \"newpath\" to bg_name;\n"
"  for qq within bgfill:\n"
"    q := pathpart qq;\n"
"    tmp:=length q;\n"
"    s := decimal(roundone(xpart point tmp of q)) & \" \" \n"
"             & decimal(roundone(ypart point tmp of q)) & \" m\";\n"
"    write s & \"oveto\" to bg_name;\n"
"    write s to clip_name;\n"
"    for i:=tmp downto 1:\n"
"        s :=  decimal(roundone(xpart precontrol i of q)) & \" \" \n"
"             & decimal(roundone(ypart precontrol i of q)) & \" \"\n"
"             & decimal(roundone(xpart postcontrol i-1 of q)) & \" \" \n"
"             & decimal(roundone(ypart postcontrol i-1 of q)) & \" \"\n"
"             & decimal(roundone(xpart point i-1 of q)) & \" \" \n"
"             & decimal(roundone(ypart point i-1 of q)) & \" c\";\n"
"        write s & \"urveto\" to bg_name;\n"
"        write s to clip_name;\n"
"    endfor;\n"
"  endfor;\n"
"  write \"closepath fill\" to bg_name;\n"
"  write \"showpage\" to bg_name;\n"
"  write \"%%EOF\" to bg_name;\n"
"  write EOF to bg_name;\n"
"  write EOF to clip_name;\n"
"  bgfill:=nullpicture;\n"
"enddef;\n"
"\n"
"\n"
"\n"
"vardef buildcycle(text ll) =\n"
"  save ta_, tb_, k_, i_, pp_; path pp_[];\n"
"  k_=0;\n"
"  for q=ll: pp_[incr k_]=q; endfor\n"
"  i_=k_;\n"
"  for i=1 upto k_:\n"
"    (ta_[i], length pp_[i_]-tb_[i_]) =\n"
"      pp_[i] intersectiontimes reverse pp_[i_];\n"
"    if ta_[i]<0:\n"
"      message(\"[Error: area borders \"& area_border[i] &\" and \"& \n"
"         area_border[i_] &\" don't intersect in scrap \" & current_scrap &\n"
"         \" (file \" & current_src & \")]\");\n"
"      area_border_errors := area_border_errors + 1;\n"
"    fi\n"
"    i_ := i;\n"
"  endfor\n"
"  for i=1 upto k_: subpath (ta_[i],tb_[i]) of pp_[i] .. endfor\n"
"    cycle\n"
"enddef;\n"
"\n"
"vardef unitvector primary z = \n"
"  if (z<>(0,0)):\n"
"    z/abs z \n"
"  else:\n"
"    hide(thwarning(\"strange path\"))\n"
"    (0,epsilon)\n"
"  fi\n"
"enddef;\n"
"\n"
"def thwarning (expr m) = \n"
"  message(\"[Warning: \" & m & \" in scrap \" & current_scrap & \"]\");\n"
"enddef;\n"
"\n"
"def check_area_borders = \n"
"  if area_border_errors > 0:\n"
"  fi;\n"
"enddef;\n"
"\n"
"%%%%%%%%%%%% Map symbols management %%%%%%%%%%%%%%%%%%%\n"
"\n"
"def mapsymbol (expr name, set, warning) = \n"
"  string s, stype, lname, ID;\n"
"  stype = substring (0,1) of name;\n"
"  lname = name & \"_\" & set;\n"
"  ID := \"ID_\" & lname;\n"
"  if (known scantokens ID):\n"
"    if stype = \"a\":\n"
"      s = \"def \" & name & \" = scantokens(\" & ditto & lname & ditto & \") enddef;\";\n"
"    else:\n"
"      s = \"let \" & name & \" = \" & lname & \";\";\n"
"    fi;\n"
"    scantokens s;\n"
"  elseif warning:  \n"
"    message(\"[Warning: undefined symbol `\" & lname & \"']\");\n"
"  fi;\n"
"enddef;\n"
"\n"
"%def hidesymbol (expr name) =\n"
"%  string s, stype;\n"
"%  stype = substring (0,1) of name;\n"
"%  if stype = \"a\":\n"
"%    s = \"def \" & name & \" = scantokens(\" & ditto & \"a_empty\" & ditto & \") enddef;\";\n"
"%  else:\n"
"%    s = \"vardef \" & name & \"@# (text t) = enddef;\";\n"
"%  fi;\n"
"%  scantokens s;\n"
"%  write name to \"missed.dat\";\n"
"%enddef;\n"
"\n"
"def initsymbol (expr name) =\n"
"  s := \"ID_\" & name & \" = 1\";\n"
"  scantokens s;\n"
"enddef;\n"
"\n"
"%%%\n"
"\n"
"% comment out groups in order to use 'save ATTR_*' appropriately\n"
"\n"
"def beginfig(expr c) =\n"
"%  begingroup\n"
"  charcode:=c;\n"
"  clearxy; clearit; clearpen;\n"
"  pickup defaultpen;\n"
"  drawoptions();\n"
"  scantokens extra_beginfig;\n"
"  \n"
"  save smartll, smartur; \n"
"  pair smartll[], smartur[]; \n"
"  smart_count := 0;\n"
"enddef;\n"
"\n"
"def endfig =\n"
"  scantokens extra_endfig;\n"
"  shipit;\n"
"%  endgroup\n"
"enddef;\n"
"\n"
"\n"
"%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n"
"% P. Bolek's MPATTERN package adapted and simplified for Therion\n"
"% (with the same user interface except of patterncolor)\n"
"%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n"
"\n"
"string Pname_, PXYsteps_;\n"
"string Pmatrix_;\n"
"\n"
"numeric Pnum_; Pnum_=0;\n"
"\n"
"def PmakeBB_=\n"
"   PBBox_ := \"[\" & decimal Plft_ & \" \" & decimal Plow_ & \" \"\n"
"   & decimal Prt_ & \" \" & decimal Pup_ & \"]\";\n"
"enddef;\n"
"\n"
"def Psteps_=\n"
"   PXYsteps_ := decimal\n"
"     if unknown PXStep_: (Prt_-Plft_) else: PXStep_ fi \n"
"   & \":\" & decimal\n"
"     if unknown PYStep_: (Pup_-Plow_) else: PYStep_ fi;\n"
"enddef;\n"
"   \n"
"vardef Pfindbounds_=\n"
"   Plow_ = ypart (llcorner currentpicture);\n"
"   Plft_ = xpart (llcorner currentpicture);\n"
"   Pup_ = ypart (urcorner currentpicture);\n"
"   Prt_ = xpart (urcorner currentpicture);\n"
"   PmakeBB_;\n"
"enddef;\n"
"\n"
"def PmakePattern_(expr name)=\n"
"  write decimal (Pnum_*epsilon) & \":\"\n"
"    & jobname & \".\" & decimal charcode & \":\"\n"
"    & PBBox_ & \":\"\n"
"    & PXYsteps_ & \":\"\n"
"    & Pmatrix_ \n"
"  to \"patterns.dat\"\n"
"enddef;\n"
"\n"
"% User interface macros\n"
"\n"
"vardef patternbbox(expr a)(text b)=\n"
"   save Pi_, Pz_;\n"
"   numeric Pi_, Pz_[];\n"
"   if pair a:\n"
"      Plft_:=min(xpart(a),xpart(b)); Plow_:=min(ypart(a),ypart(b));\n"
"      Prt_:=max(xpart(a),xpart(b));  Pup_:=max(ypart(a),ypart(b));\n"
"   else:\n"
"      Pi_=1;\n"
"      for t=b:\n"
"\t Pz_[Pi_]=t;\n"
"\t Pi_:=Pi_+1;\n"
"      endfor;\n"
"      Plft_:=min(a,Pz_2);   Plow_:=min(Pz_1,Pz_3);\n"
"      Prt_:=max(a,Pz_2); Pup_:=max(Pz_1,Pz_3);\n"
"   fi;\n"
"   PmakeBB_;\n"
"enddef;\n"
"\n"
"def beginpattern(suffix name)=\n"
"  numeric PXStep_, PYStep_;\n"
"  numeric Plow_, Plft_, Pup_, Prt_;\n"
"  string PBBox_;\n"
"  Pmatrix_:=\"[1 0 0 1 0 0]\";\n"
"  Pname_:=str name;\n"
"  Pnum_:=Pnum_+1;\n"
"  beginfig(Pnum_+4000);\n"
"enddef;\n"
"\n"
"def endpattern=\n"
"  if unknown PBBox_:\n"
"     Pfindbounds_;\n"
"  fi;\n"
"  endfig;\n"
"  Psteps_;\n"
"  PmakePattern_(Pname_);\n"
"  scantokens(Pname_ & \"=Pnum_;\");\n"
"enddef;\n"
"\n"
"picture pattpict;\n"
"color patterncolor_;\n"
"patterncolor_ := black;\n"
"\n"
"primarydef p withpattern s=\n"
"  if known s:\n"
"\n"
"    hide(pattpict := image(draw (0,0)--(10,10));\n"
"      for i within pattpict:\n"
"        patterncolor_ := (redpart i, greenpart i, bluepart i);\n"
"      endfor;)\n"
"\n"
"    p withcolor (epsilon, 10*epsilon, s*epsilon)\n"
"    if known mpversion:\n"
"      if scantokens(mpversion)>=1.000: \n"
"        withprescript(decimal redpart   patterncolor_ & \" \" &\n"
"                      decimal greenpart patterncolor_ & \" \" &\n"
"                      decimal bluepart  patterncolor_ & \" THsetpatterncolor\")\n"
"      fi;\n"
"    fi;\n"
"  else:\n"
"    p withcolor (1,0,0);\n"
"    message(\"Warning: undefined pattern ignored\");\n"
"  fi;  \n"
"enddef;\n"
"   \n"
"def patterntransform expr t=\n"
"   Pmatrix_ := \"[\" & decimal xxpart t\n"
"              & \" \" & decimal yxpart t\n"
"              & \" \" & decimal xypart t\n"
"              & \" \" & decimal yypart t\n"
"              & \" \" & decimal xpart t\n"
"              & \" \" & decimal ypart t & \"]\";\n"
"enddef;\n"
"\n"
"def patternxstep expr t=\n"
"   PXStep_ = t;\n"
"enddef;\n"
"\n"
"def patternystep expr t=\n"
"   PYStep_ = t;\n"
"enddef;\n"
"\n"
"def patternstep text t=\n"
"   if pair t:\n"
"      PXStep_ = xpart t;\n"
"      PYStep_ = ypart t;\n"
"   else:\n"
"      (PXStep_,PYStep_)=t;\n"
"   fi;\n"
"enddef;\n"
"\n"
"def patterncolor expr t=\n"
"  message(\"Warning: patterncolor not supported in Therion\");\n"
"enddef;\n"
"\n"
"%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n"
"% end of pattern macros\n"
"%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n"
"\n"
"% transparent rgb colors\n"
"\n"
"numeric RGBnum; RGBnum=0;\n"
"string RGBname;\n"
"\n"
"def def_transparent_rgb (suffix name)(expr r, g, b) =\n"
"  RGBnum := RGBnum+1;\n"
"  RGBname := str name;\n"
"  write decimal (RGBnum*epsilon) & \":\"\n"
"    & decimal r & \" \"\n"
"    & decimal g & \" \"\n"
"    & decimal b \n"
"  to \"rgbcolors.dat\";\n"
"  scantokens(RGBname & \":=RGBnum;\");\n"
"enddef;\n"
"\n"
"primarydef p withtransparentcolor s=\n"
"   p withcolor (epsilon, 12*epsilon, s*epsilon);\n"
"enddef;\n"
"\n"
"def_transparent_rgb(tr_white, 1, 1, 1);\n"
"def_transparent_rgb(tr_blue, 0, 0, 1);\n"
"def_transparent_rgb(tr_black, 0, 0, 0);\n"
"def_transparent_rgb(tr_bg, \n"
"               redpart background, greenpart background, bluepart background);\n"
"\n"
"%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n"
"% some useful macros from H. Hagen's MetaFun package\n"
"%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n"
"\n"
"vardef paired (expr d) =\n"
"  if pair d : d else : (d,d) fi\n"
"enddef ;\n"
"\n"
"primarydef p randomshifted s = \n"
"  begingroup ; save ss ; pair ss ; ss := paired(s) ; \n"
"  p shifted (-.5xpart ss + uniformdeviate xpart ss,\n"
"             -.5ypart ss + uniformdeviate ypart ss) \n"
"  endgroup \n"
"enddef ; \n"
"\n"
"primarydef p randomized s =\n"
"  (if path p : \n"
"    for i=0 upto length(p)-1 :\n"
"      ((point       i    of p) randomshifted s) .. controls \n"
"      ((postcontrol i    of p) randomshifted s) and \n"
"      ((precontrol (i+1) of p) randomshifted s) .. \n"
"    endfor \n"
"    if cycle p : \n"
"      cycle \n"
"    else :\n"
"      ((point length(p) of p) randomshifted s) \n"
"    fi\n"
"  elseif pair p :\n"
"    p randomshifted s  \n"
"  elseif color p :\n"
"    if color s : \n"
"      (uniformdeviate redpart   s * redpart   p,\n"
"       uniformdeviate greenpart s * greenpart p,\n"
"       uniformdeviate bluepart  s * bluepart  p)  \n"
"    elseif pair s : \n"
"      ((xpart s + uniformdeviate (ypart s - xpart s)) * p)  \n"
"    else :  \n"
"      (uniformdeviate s * p)  \n"
"    fi \n"
"  else :\n"
"    p + uniformdeviate s  \n"
"  fi)  \n"
"enddef ; \n"
"\n"
"primarydef p llmoved d =\n"
"  ((llcorner p) shifted (-xpart paired(d),-ypart paired(d)))\n"
"enddef ;\n"
"\n"
"primarydef p lrmoved d =\n"
"  ((lrcorner p) shifted (+xpart paired(d),-ypart paired(d)))\n"
"enddef ;\n"
"\n"
"primarydef p urmoved d =\n"
"  ((urcorner p) shifted (+xpart paired(d),+ypart paired(d)))\n"
"enddef ;\n"
"\n"
"primarydef p ulmoved d =\n"
"  ((ulcorner p) shifted (-xpart paired(d),+ypart paired(d)))\n"
"enddef ;\n"
"\n"
"primarydef p smoothed d =\n"
"  (p llmoved (-xpart paired(d),0) -- p lrmoved (-xpart paired(d),0) {right} .. \n"
"   p lrmoved (0,-ypart paired(d)) -- p urmoved (0,-ypart paired(d)) {up}    .. \n"
"   p urmoved (-xpart paired(d),0) -- p ulmoved (-xpart paired(d),0) {left}  ..\n"
"   p ulmoved (0,-ypart paired(d)) -- p llmoved (0,-ypart paired(d)) {down}  .. cycle) \n"
"enddef ;\n"
"\n"
"vardef punked primary p = \n"
"  (point 0 of p for i=1 upto length(p)-1 : -- point i of p endfor \n"
"   if cycle p : -- cycle else : -- point length(p) of p fi)  \n"
"enddef ;  \n"
"\n"
"%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n"
"% end of MetaFun macros\n"
"%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n"
"\n"
"% we input map symbol definitions\n"
"\n"
"\n\n\n%%%%% INPUT thPoint %%%%%\n\n\n"
"%% therion source code\n"
"%%\n"
"%% This file defines macros for point map symbols\n"
"%%\n"
"%% $Date: 2003/07/01 09:06:44 $\n"
"%% $RCSfile: thPoint.mp,v $\n"
"%% $Revision: 1.8 $\n"
"%%\n"
"%% Copyright (C) 2000-2004 Martin Budaj\n"
"%%\n"
"%% -------------------------------------------------------------------- \n"
"%% This program is free software; you can redistribute it and/or modify\n"
"%% it under the terms of the GNU General Public License as published by\n"
"%% the Free Software Foundation; either version 2 of the License, or\n"
"%% any later version.\n"
"%%\n"
"%% This program is distributed in the hope that it will be useful,\n"
"%% but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
"%% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n"
"%% GNU General Public License for more details.\n"
"%% \n"
"%% You should have received a copy of the GNU General Public License\n"
"%% along with this program; if not, write to the Free Software\n"
"%% Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n"
"%% --------------------------------------------------------------------\n"
"\n"
"pair U;\n"
"\n"
"def p_stalactite_UIS(expr pos,theta,sc,al) =\n"
"    U:=(.15u, .4u);\n"
"    T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"    pickup PenC;\n"
"    thdraw (0,-.4u) -- (0,.15u) -- (-.15u,.4u);\n"
"    thdraw (0,.15u) -- (.15u,.4u);\n"
"enddef;\n"
"\n"
"def p_stalagmite_UIS(expr pos,theta,sc,al) =\n"
"    U:=(.15u,.4u);\n"
"    T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"    pickup PenC;\n"
"    thdraw (0,.4u) -- (0,-.15u) -- (-.15u,-.4u);\n"
"    thdraw (0,-.15u) -- (.15u,-.4u);\n"
"enddef;\n"
"\n"
"def p_pillar_UIS(expr pos,theta,sc,al) =\n"
"    U:=(.15u,.4u);\n"
"    T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"    pickup PenC;\n"
"    thdraw (0,.15u)--(0,-.15u);\n"
"    thdraw (-.15u,-.4u)--(0,-.15u)--(.15u,-.4u);\n"
"    thdraw (-.15u,.4u)--(0,.15u)--(.15u,.4u);\n"
"enddef;\n"
"\n"
"def p_curtain_UIS(expr pos,theta,sc,al) =\n"
"    U:=(.15u,.4u);\n"
"    T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"    pickup PenC;\n"
"    thdraw (-.15u,.4u)--(0,.15u)--(.15u,.4u);\n"
"    thdraw (0,.15u)--(0,0){dir 180}..(-.12u,-.11u)..{dir 0}(0,-.22u)--(0,-.4u);\n"
"enddef;\n"
"\n"
"def p_helictite_UIS(expr pos,theta,sc,al) =\n"
"    U:=(.2u,.4u);\n"
"    T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"    pickup PenC;\n"
"    thdraw (0,.4u)--(0,-.4u);\n"
"    p := (-.2u,.4u)---(-.2u,.1u){down}..{dir -10}(-.1u,0.02u)---origin;\n"
"    thdraw p;\n"
"    thdraw p reflectedabout (origin,(0,u)) reflectedabout (origin,(u,0));\n"
"enddef;\n"
"\n"
"def p_sodastraw_UIS(expr pos,theta,sc,al) =\n"
"    U:=(.5u,.25u);\n"
"    T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"    pickup PenC;\n"
"    thdraw (-.5u,.2u)--(.5u,.2u);\n"
"    pickup PenD;\n"
"    thdraw (-.4u,.2u)--(-.4u,0);\n"
"    thdraw (-.12u,.2u)--(-.12u,-.25u);\n"
"    thdraw (.02u,.2u)--(.02u,-.1u);\n"
"    thdraw (.23u,.2u)--(.23u,-.19u);\n"
"    thdraw (.35u,.2u)--(.35u,-.15u);\n"
"enddef;\n"
"\n"
"def p_crystal_UIS (expr pos,theta,sc,al)=\n"
"    U:=(.35u,.35u);\n"
"    T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"    pickup PenC;\n"
"    p := ((-.35*u,0)--(.35*u,0));\n"
"    thdraw p;\n"
"    thdraw p rotated (60);\n"
"    thdraw p rotated (120);\n"
"enddef;\n"
"\n"
"def p_flowstone_UIS (expr pos,theta,sc,al)=\n"
"    U:=(.45u,.1u);\n"
"    T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"    pickup PenC;\n"
"    p := ((-.15*u,0)--(.15*u,0));\n"
"    thdraw p shifted (.3u,-.1u);\n"
"    thdraw p shifted (-.3u,-.1u);\n"
"    thdraw p shifted (0,.1u);\n"
"enddef;\n"
"\n"
"def p_moonmilk_UIS (expr pos,theta,sc,al)=\n"
"    U:=(.5u,.2u);\n"
"    T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"    pickup PenC;\n"
"    thdraw (-.5u,-.2u){up}..{dir -60}(-.18u,-.105u){dir 80}..\n"
"        {dir-80}(.18u,-.105u){dir 60}..{down}(.5u,-.2u);\n"
"enddef;\n"
"\n"
"def p_wallcalcite_UIS (expr pos,theta,sc,al)=\n"
"    U:=(.2u,.2u);\n"
"    T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"    pickup PenC;\n"
"    thdraw (-.2u,-.2u)--(0,.1u)--(.2u,-.2u);\n"
"enddef;\n"
"\n"
"def p_popcorn_UIS (expr pos,theta,sc,al)=\n"
"    U:=(.5u,.2u);\n"
"    T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"    pickup PenC;\n"
"    thdraw (-.5u,-.2u)--(.5u,-.2u);\n"
"    pickup PenD;\n"
"    thdraw (-.3u,-.2u)--(-.3u,.1u);\n"
"    thdraw (0,-.2u)--(0,.1u);\n"
"    thdraw (.3u,-.2u)--(.3u,.1u);\n"
"    thfill fullcircle scaled .2u shifted (-.3u,.1u);\n"
"    thfill fullcircle scaled .2u shifted (0,.1u);\n"
"    thfill fullcircle scaled .2u shifted (.3u,.1u);\n"
"enddef;\n"
"\n"
"def p_disk_UIS (expr pos,theta,sc,al)=\n"
"    U:=(.2u,.3u);\n"
"    T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"    pickup PenC;\n"
"    thdraw (-.2u,-.3u)--origin--(.2u,-.3u);\n"
"    p:=fullcircle scaled .3u shifted (0,.15u);\n"
"    thclean p;\n"
"    thdraw p;\n"
"enddef;\n"
"\n"
"def p_gypsum_NSS (expr pos,theta,sc,al)=\n"
"    U:=(.25u,.25u);\n"
"    T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"    pickup PenC;\n"
"    thdraw (-.25u,0)--(.25u,0);\n"
"    thdraw (0,-.25u)--(0,.25u);\n"
"enddef;\n"
"\n"
"def p_aragonite_NSS (expr pos,theta,sc,al)=\n"
"    U:=(.3u,.4u);\n"
"    T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"    pickup PenC;\n"
"    thdraw (0,-.4u)--(0,.3u);\n"
"    thdraw (0,-.1u){dir 40}..{dir 5}(.3u,.08u);\n"
"    thdraw (0,-.1u){dir 140}..{dir 175}(-.3u,.08u);\n"
"    thdraw (0,.2u){dir 30}..{dir 5}(.25u,.3u);\n"
"    thdraw (0,.2u){dir 150}..{dir 175}(-.25u,.3u);\n"
"enddef;\n"
"\n"
"\n"
"def p_cavepearl_SKBB (expr pos,theta,sc,al)=\n"
"    U:=(.25u,.25u);\n"
"    T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"    pickup PenC;\n"
"    p:=fullcircle scaled .25u shifted (0,.16u);\n"
"    thdraw p;\n"
"    thdraw p rotated 120;\n"
"    thdraw p rotated 240;\n"
"enddef;\n"
"\n"
"def p_gypsumflower_NSS (expr pos,theta,sc,al)=\n"
"    U:=(.4u,.3u);\n"
"    T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"    pickup PenC;\n"
"%    thdraw (.2u,0){left}..(0,.2u)..(.25u,.35u)..(.5u,0)..\n"
"%        (.1u,-.3u)..{dir 125}(-.5u,.2u);\n"
"    thdraw (.18u,0){left}..(0,.15u)..(.2u,.3u)..(.4u,0)..\n"
"        (.15u,-.28u)..{dir 120}(-.4u,.15u);\n"
"enddef;\n"
"\n"
"def p_rimstonepool_ASF (expr pos,theta,sc,al)=\n"
"    U:=(.4u,.2u);\n"
"    T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"    pickup PenC;\n"
"    p := (-.4u,.2u){dir -70}..{dir 70}(.4u,.2u);\n"
"    thfill buildcycle(p,((.5u,.1u)--(-.5u,.1u)));\n"
"    thdraw p;\n"
"enddef;\n"
"\n"
"def p_rimstonedam_ASF (expr pos,theta,sc,al)=\n"
"    U:=(.4u,.2u);\n"
"    T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"    pickup PenC;\n"
"    thdraw (-.4u,.2u){dir -70}..{dir 70}(.4u,.2u);\n"
"enddef;\n"
"\n"
"def p_anastomosis_UIS (expr pos,theta,sc,al)=\n"
"    U:=(.4u,.3u);\n"
"    T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"    pickup PenC;\n"
"    p:=(-.4u,-.2u)--(-.3u,-.3u)--(0,.3u)--(.1u,.2u);\n"
"    thdraw p;\n"
"    thdraw p shifted (.3u,0);\n"
"enddef;\n"
"\n"
"def p_karren_UIS (expr pos,theta,sc,al)=\n"
"    U:=(.5u,.4u);\n"
"    T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"    pickup PenC;\n"
"    thdraw (-.5u,-.3u){dir -85}..{dir 85}(-.32u,-.3u)..(-.28u,.3u){dir 85}..\n"
"        {dir -85}(-.12u,.3u)..(-.08u,-.3u){dir-85}..{dir 85}(.08u,-.3u)..\n"
"        {dir85}(.12u,.3u)..(.28u,.3u){dir -85}..(.32u,-.3u){dir -85}..\n"
"        {dir 85}(.5u,-.3u);\n"
"enddef;\n"
"\n"
"def p_scallop_UIS (expr pos,theta,sc,al)=\n"
"    U:=(.2u,.4u);\n"
"    T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"    pickup PenC;\n"
"    thdraw (0,-.4u){dir 125}..{dir 105}(-.2u,.1u){up}..\n"
"        {down}(.2u,.1u){dir -105}...{dir -125}(0,-.4u);\n"
"enddef;\n"
"\n"
"def p_flute_UIS (expr pos,theta,sc,al)=\n"
"    U:=(.5u,.2u);\n"
"    T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"    pickup PenC;\n"
"    thdraw (-.5u,.2u)--(.5u,.2u);\n"
"    thdraw (-.3u,.2u){dir -70}..{dir 70}(.3u,.2u);\n"
"enddef;\n"
"\n"
"def p_raft_NSS (expr pos,theta,sc,al)=\n"
"    U:=(.5u,.2u);\n"
"    T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"    pickup PenC;\n"
"    thdraw (-.5u,.2u){dir -80}..(-.3u,-.2u)..origin..(.3u,.2u)..\n"
"        {dir -80}(.5u,-.2u);\n"
"enddef;\n"
"\n"
"def p_raftcone_NSS (expr pos,theta,sc,al)=\n"
"    U:=(.3u,.4u);\n"
"    T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"    pickup PenC;\n"
"    thdraw (-.3u,-.4u)--(0,.4u)--(.3u,-.4u);\n"
"enddef;\n"
"\n"
"def p_spring_SKBB (expr pos,theta,sc,al)=\n"
"  U:=(.3u,.2u);\n"
"  T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"  pickup PenC;\n"
"  thdraw (-.3u,.2u){down}..(0,-.2u)..{up}(.3u,.2u);\n"
"enddef;\n"
"\n"
"def p_sink_SKBB (expr pos,theta,sc,al)=\n"
"  U:=(.3u,.2u);\n"
"  T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"  pickup PenC;\n"
"  thdraw (-.3u,-.2u){up}..(0,.2u)..{down}(.3u,-.2u);\n"
"enddef;\n"
"\n"
"def p_narrowend_UIS (expr pos,theta,sc,al)=\n"
"    U:=(.1u,.4u);\n"
"    T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"    pickup PenC;\n"
"    thdraw (-.1u,-.4u)--(-.1u,.4u);\n"
"    thdraw (.1u,-.4u)--(.1u,.4u);\n"
"enddef;\n"
"\n"
"def p_lowend_UIS (expr pos,theta,sc,al)=\n"
"    U:=(.4u,.1u);\n"
"    T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"    pickup PenC;\n"
"    thdraw (-.4u,-.1u)--(.4u,-.1u);\n"
"    thdraw (-.4u,.1u)--(.4u,.1u);\n"
"enddef;\n"
"\n"
"def p_lowend_NSS (expr pos,theta,sc,al)=\n"
"    U:=(.4u,0);\n"
"    T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"    pickup PenC;\n"
"    thdraw (-.4u,0)--(.4u,0);\n"
"enddef;\n"
"\n"
"def p_flowstonechoke_NSS (expr pos,theta,sc,al)=\n"
"    U:=(.4u,.3u);\n"
"    T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"    pickup PenC;\n"
"    p:=(-.4u,-.4u){right}..{dir120}(-.2u,-.2u){dir -20}..{up}(0,0);\n"
"    thdraw p;\n"
"    thdraw p shifted (0,.2u);\n"
"    thdraw p reflectedabout (origin,down);\n"
"    thdraw p reflectedabout (origin,down) shifted (0,.2u);\n"
"enddef;\n"
"\n"
"def p_breakdownchoke_NSS (expr pos,theta,sc,al)=\n"
"    U:=(.5u,.2u);\n"
"    T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"    pickup PenC;\n"
"    thdraw (-.5u,-.1u)--(-.15u,.05u)--(-.48u,.2u)--cycle;\n"
"    thdraw (-.2u,-.2u)--(.15u,-.18u)--(-.08u,.14u)--cycle;\n"
"    thdraw (.1u,0)--(.4u,-.1u)--(.5u,.2u)--(.1u,.2u)--cycle;\n"
"enddef;\n"
"\n"
"def p_bedrock_ASF (expr pos,theta,sc,al)=\n"
"    U:=(.5u,.2u);\n"
"    T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"    pickup PenC;\n"
"    thdraw (-.5u,0)--(.5u,0);\n"
"    thdraw (-.3u,0)--(-.3u,.2u);\n"
"    thdraw (.3u,0)--(.3u,-.2u);\n"
"enddef;\n"
"\n"
"def p_sand_UIS (expr pos,theta,sc,al)=\n"
"    U:=(.2u,.2u);\n"
"    T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"    pickup PenB;\n"
"    thdraw (0,.2u);\n"
"    thdraw (0,.2u) rotated 120;\n"
"    thdraw (0,.2u) rotated 240;\n"
"enddef;\n"
"\n"
"def p_clay_SKBB (expr pos,theta,sc,al) =\n"
"    U:=(.3u,.3u);\n"
"    T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"    pickup PenC;\n"
"    thdraw (-.3u,0){up}..origin{down}..{up}(0.3u,0);\n"
"enddef;\n"
"\n"
"def p_pebbles_UIS (expr pos,theta,sc,al)=\n"
"    U:=(.45u,.35u);\n"
"    T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"    pickup PenC;\n"
"    p:=superellipse((.2u,0),(0,.1u),(-.2u,0),(0,.-.1u),.75);\n"
"    thdraw p rotated 20 shifted (0,.25u);\n"
"    thdraw p rotated -37 shifted (.25u,-.25u);\n"
"    thdraw p rotated -62 shifted (-.25u,-.25u);\n"
"enddef;\n"
"\n"
"def p_debris_UIS (expr pos,theta,sc,al)=\n"
"    U:=(.4u,.4u);\n"
"    T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"    pickup PenC;\n"
"    thdraw (-.3u,-.4u)--(0,-.22u)--(-.4u,-.1u)--cycle;\n"
"    thdraw (.2u,-.4u)--(.4u,-.1u)--(.1u,-.1u)--cycle;\n"
"    thdraw (-.1u,0)--(.2u,.3u)--(-.2u,.3u)--cycle;\n"
"enddef;\n"
"\n"
"def p_blocks_UIS (expr pos,theta,sc,al)=\n"
"    U:=(.5u,.5u);\n"
"    T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"    pickup PenC;\n"
"    thdraw (-.5u,-.5u)--(.3u,-.4u)--(-.17u,.2u)--cycle;\n"
"    thdraw (.25u,-.25u)--(.5u,-.15u)--(.3u,.5u)--(-.1u,.5u)--cycle;\n"
"    thdraw (-.27u,0)--(-.1u,.3u)--(-.5u,.35u)--cycle;\n"
"    pickup PenD;\n"
"    thdraw (-.5u,-.5u)--(-.1u,-.2u)--(-.17u,.2u);\n"
"    thdraw (-.1u,-.2u)--(.3u,-.4u);\n"
"    thdraw (.25u,-.25u)--(.3u,0)--(.2u,.2u)--(-.1u,.5u);\n"
"    thdraw (.3u,.5u)--(.2u,.2u);\n"
"    thdraw (.5u,-.15u)--(.3u,0);\n"
"enddef;\n"
"\n"
"def p_water_UIS (expr pos,theta,sc,al)=\n"
"    U:=(.425u,.3u);\n"
"    T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"    pickup PenD;\n"
"    p:=fullcircle xscaled (.85u) yscaled (.6u);\n"
"    thfill p withpattern pattern_water_UIS;\n"
"    thdraw p;\n"
"enddef;\n"
"\n"
"def p_ice_UIS (expr pos,theta,sc,al)=\n"
"    U:=(.4u,.35u);\n"
"    T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"    pickup PenC;\n"
"    p := (0,.05u)--(0,.35u);\n"
"    thdraw p;\n"
"    thdraw p shifted (-.25u,-.3u);\n"
"    thdraw p shifted (.25u,-.3u);\n"
"    p := (-0.15u,.2u)--(0.15u,.2u);\n"
"    thdraw p;\n"
"    thdraw p shifted (-.25u,-.3u);\n"
"    thdraw p shifted (.25u,-.3u);\n"
"enddef;\n"
"\n"
"def p_snow_SKBB (expr pos,theta,sc,al)=\n"
"    U:=(.35u,.35u);\n"
"    T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"    pickup PenC;\n"
"    p := origin--(0,.25*u);\n"
"    q := ((0,.35u)--(0,0.25u)--(0.1u,0.25u)) rotatedaround ((0,0.25u),45);\n"
"    thdraw p;\n"
"    thdraw p rotated (60);\n"
"    thdraw p rotated (120);\n"
"    thdraw p rotated (180);\n"
"    thdraw p rotated (240);\n"
"    thdraw p rotated (300);\n"
"    thdraw q;\n"
"    thdraw q rotated (60);\n"
"    thdraw q rotated (120);\n"
"    thdraw q rotated (180);\n"
"    thdraw q rotated (240);\n"
"    thdraw q rotated (300);\n"
"enddef;\n"
"\n"
"\n"
"def p_archeomaterial_UIS (expr pos,theta,sc,al)=\n"
"    U:=(.4u,.4u);\n"
"    T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"    pickup PenC;\n"
"    p := fullcircle scaled .8u; \n"
"    thdraw (-.5u,-.5u)--origin cutbefore p;\n"
"    thdraw (-.5u,.5u)--origin cutbefore p;\n"
"    thdraw origin--(.4u,0);\n"
"    thdraw p;\n"
"enddef;\n"
"\n"
"def p_paleomaterial_UIS (expr pos,theta,sc,al)=\n"
"    U:=(.4u,.4u);\n"
"    T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"    thfill (-.4u,-.2u)..(-.2u,-.08u)---(-.1u,.05u)---(0,.2u)..(-.03u,.4u)..\n"
"        (.2u,.3u)..(.35u,.25u)..(.2u,.2u)---origin---(-.1u,-.17u)..\n"
"        (-.08u,-.25u){dir -120}..(-.3u,-.23u)\n"
"        ..cycle;\n"
"enddef;\n"
"\n"
"def p_guano_UIS (expr pos,theta,sc,al)=\n"
"    U:=(.4u,.35u);\n"
"    T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"    pickup PenC;\n"
"    thdraw (-.4u,.2u){dir 40}..{down}(0,-.35u){up}..{dir-40}(.4u,.2u);\n"
"enddef;\n"
"\n"
"def p_vegetabledebris_ASF (expr pos,theta,sc,al)=\n"
"    U:=(.38u,.3u);\n"
"    T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"    pickup PenC;\n"
"    thdraw (-.3u,-.3u)--(0,.3u);\n"
"    thdraw (0,-.3u)--(.3u,.3u);\n"
"    thdraw (-.25u,.13u)--(.38u,.13u);\n"
"    thdraw (-.38u,-.13u)--(.25u,-.13u);\n"
"enddef;\n"
"\n"
"def p_root_ASF (expr pos,theta,sc,al)=\n"
"    U:=(.1u,.5u);\n"
"    T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"    pickup PenC;\n"
"    thdraw (-.1u,-.5u)--(-.1u,.5u);\n"
"    p:=(-.1u,-.3u)--(.1u,-.5u);\n"
"    thdraw p;\n"
"    thdraw p shifted (0,.2u);\n"
"    thdraw p shifted (0,.4u);\n"
"enddef;\n"
"\n"
"def p_entrance_UIS (expr pos,theta,sc,al)=\n"
"    U:=(.2u,.5u);\n"
"    T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"    thfill (-.2u,-.5u)--(0,.5u)--(.2u,-.5u)--cycle;\n"
"enddef;\n"
"\n"
"def p_waterflow_paleo_UIS (expr pos,theta,sc,al)=\n"
"    U:=(.2u,u);\n"
"    T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"    pickup PenC;\n"
"    thdraw (0,-u)--(0,u);\n"
"    thdraw halfcircle scaled .4u shifted (0,-.4u);\n"
"    p:=(-.15u,.6u)--(0,u)--(.15u,.6u)--cycle;\n"
"    thfill p;\n"
"    thdraw p;\n"
"enddef;\n"
"\n"
"def p_gradient_UIS (expr pos,theta,sc,al)=\n"
"    U:=(.15u,u);\n"
"    T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"    pickup PenC;\n"
"    thdraw (0,-u)--(0,u);\n"
"    p:=(-.15u,.6u)--(0,u)--(.15u,.6u)--cycle;\n"
"    thfill p;\n"
"    thdraw p;\n"
"enddef;\n"
"\n"
"def p_gradient_BCRA (expr pos,theta,sc,al)=\n"
"    U:=(.25u,0.7u);\n"
"    T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"    thfill (-.25u,-0.7u)--(0,.7u)--(.25u,-.7u)--cycle;\n"
"enddef;\n"
"\n"
"% by Philip Schuchardt\n"
"def p_gradient_NSS (expr pos,theta,sc,al) =\n"
"  U:=(.7u, .6u);\n"
"  T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"  pickup PenC;\n"
"\n"
"  thdraw (-.3u, -.5u) -- (-.7u, -.2u);\n"
"  thdraw (-.2u, -.4u) -- (-.4u, .3u);\n"
"  thdraw (0u, -.3u) -- (0u, .6u);\n"
"  thdraw (.3u, -.5u) -- (.7u, -.2u);\n"
"  thdraw (.2u, -.4u) -- (.4u, .3u);\n"
"enddef;\n"
"\n"
"def p_waterflow_permanent_UIS (expr pos,theta,sc,al)=\n"
"    U:=(.15u,.5u);\n"
"    T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"    pickup PenC;\n"
"    p:=(0,.5u){down}..(.12u,.3u)..(-.15u,.15u)..(.13u,0)..\n"
"        (-.08u,-.2u)..{down}(0,-.5u);\n"
"    p:=p rotated 180;\n"
"    thdraw p;\n"
"    thdrawoptions();\n"
"    oldahlength:=ahlength; ahlength:=2.5pt*optical_zoom;\n"
"    thdraw arrowhead p;\n"
"    thfill arrowhead p;\n"
"    ahlength:=oldahlength;\n"
"enddef;\n"
"\n"
"def p_waterflow_intermittent_UIS (expr pos,theta,sc,al)=\n"
"  thdrawoptions(dashed evenly scaled (.5 * optical_zoom));\n"
"  p_waterflow_permanent_UIS (pos,theta,sc,al);\n"
"  thdrawoptions();\n"
"enddef;\n"
"\n"
"def p_airdraught_UIS (expr pos,theta,sc,al)=\n"
"  U:=(.2u,u);\n"
"  T:=identity aligned al rotated theta scaled 1 shifted pos;\n"
"  pickup PenC;\n"
"  thdraw (0,u)--(0,-0.8u);\n"
"\tp:=(-.2u,.65u){dir 20}..{dir 90}(0,u);\n"
"\tthdraw p;\n"
"\tthdraw p reflectedabout (origin,(0,u));\n"
"\tfor i:=1 upto round(3+2*mlog(sc)/mlog 2):\n"
"\t  thdraw (0,-(1-0.2i)*u)--(.2u,-(1-0.2(i-1))*u);\n"
"\tendfor;\n"
"enddef;\n"
"\n"
"def p_airdraught_winter_UIS (expr pos,theta,sc,al)=\n"
"  U:=(.2u,u);\n"
"  T:=identity aligned al rotated theta scaled 1 shifted pos;\n"
"  pickup PenC;\n"
"  thdraw (0,u)--(0,-0.8u);\n"
"  p:=(-.2u,.65u){dir 20}..{dir 90}(0,u);\n"
"  thdraw p;\n"
"  thdraw p reflectedabout (origin,(0,u));\n"
"  for i:=1 upto round(3+2*mlog(sc)/mlog 2):\n"
"    thdraw (0,-(1-0.2i)*u)--(.2u,-(1-0.2(i-1))*u);\n"
"  endfor;\n"
"  thclean fullcircle scaled 0.6u shifted (0,0.05u);\n"
"  thdraw (-0.1732u,-0.05u) -- (0.1732u,0.15u);\n"
"  thdraw (0.1732u,-0.05u) -- (-0.1732u,0.15u);\n"
"  thdraw (0,-0.15u) -- (0,0.25u);\n"
"enddef;\n"
"\n"
"def p_airdraught_summer_UIS (expr pos,theta,sc,al)=\n"
"  U:=(.2u,u);\n"
"  T:=identity aligned al rotated theta scaled 1 shifted pos;\n"
"  pickup PenC;\n"
"  thdraw (0,u)--(0,-0.8u);\n"
"  p:=(-.2u,.65u){dir 20}..{dir 90}(0,u);\n"
"  thdraw p;\n"
"  thdraw p reflectedabout (origin,(0,u));\n"
"  for i:=1 upto round(3+2*mlog(sc)/mlog 2):\n"
"    thdraw (0,-(1-0.2i)*u)--(.2u,-(1-0.2(i-1))*u);\n"
"  endfor;\n"
"  thclean fullcircle scaled 0.6u shifted (0,0.05u);\n"
"  thdraw (-0.1732u,-0.05u) -- (0.1732u,0.15u);\n"
"  thdraw (0.1732u,-0.05u) -- (-0.1732u,0.15u);\n"
"  thdraw (0,-0.15u) -- (0,0.25u);\n"
"  thclean fullcircle scaled 0.3u shifted (0,0.05u);\n"
"  thdraw fullcircle scaled 0.2u shifted (0,0.05u);\n"
"enddef;\n"
"\n"
"\n"
"def p_station_fixed_ASF (expr pos)=\n"
"    T:=identity shifted pos;\n"
"    pickup PenD;\n"
"    pair z;\n"
"    z:=(0,.2u);\n"
"    thclean z -- (z rotated 120) -- (z rotated 240) -- cycle;\n"
"    thdraw z -- (z rotated 120) -- (z rotated 240) -- cycle;\n"
"    thdraw origin;\n"
"enddef;\n"
"\n"
"def p_station_painted_SKBB (expr pos)=\n"
"    T:=identity shifted pos;\n"
"    pickup PenC;\n"
"    thclean fullcircle scaled 0.25u;\n"
"    thdraw fullcircle scaled 0.25u;\n"
"enddef;\n"
"\n"
"def p_station_natural_ASF (expr pos)=\n"
"    T:=identity shifted pos;\n"
"    pickup PenD;\n"
"    thclean fullcircle scaled .3u;\n"
"    thdraw fullcircle scaled .3u;\n"
"    thdraw origin;\n"
"enddef;\n"
"\n"
"def p_station_temporary_ASF (expr pos)=\n"
"    T:=identity shifted pos;\n"
"    pickup PenD;\n"
"    p:=(-.2u,0)--(.2u,0);\n"
"    thdraw p;\n"
"    thdraw p rotated 90;\n"
"    thclean fullcircle scaled .16u;\n"
"    pickup PenC;\n"
"    thdraw origin;\n"
"enddef;\n"
"\n"
"let p_station_temporary_SKBB = p_station_painted_SKBB;\n"
"\n"
"def p_steps_SKBB (expr pos,r,s,al) = \n"
"    U:=(.4u, .4u);\n"
"    T:=identity aligned al shifted pos;\n"
"    thdraw unitsquare scaled .8u shifted (-0.4u,-.4u) withpen PenD;\n"
"    pickup PenC;\n"
"    thdraw (-.3u,.3u)--(-.3u,.1u)--(-.1u,.1u)--(-.1u,-.1u)--\n"
"           (.1u,-.1u)--(.1u,-.3u)--(.3u,-.3u);\n"
"enddef;\n"
"\n"
"def p_fixedladder_SKBB (expr pos,r,s,al) = \n"
"    U:=(.4u, .4u);\n"
"    T:=identity aligned al shifted pos;\n"
"    thdraw unitsquare scaled .8u shifted (-0.4u,-.4u) withpen PenD;\n"
"    pickup PenC;\n"
"    thdraw (-.15u,-.4u)--(-.15u,.4u);\n"
"    thdraw (.15u,-.4u)--(.15u,.4u);\n"
"    thdraw (-.15u,0)--(.15u,0);\n"
"    thdraw (-.15u,.2u)--(.15u,.2u);\n"
"    thdraw (-.15u,-.2u)--(.15u,-.2u);\n"
"enddef;\n"
"\n"
"def p_ropeladder_SKBB (expr pos,r,s,al) = \n"
"    U:=(.4u, .4u);\n"
"    T:=identity aligned al shifted pos;\n"
"    thdraw unitsquare scaled .8u shifted (-0.4u,-.4u) withpen PenD;\n"
"    pickup PenC;\n"
"    thdraw (.1u,-.4u)..(.2u,-.2u)..(.1u,.2u)..(.2u,.4u);\n"
"    thdraw (-.2u,-.4u)..(-.1u,-.2u)..(-.2u,.2u)..(-.1u,.4u);\n"
"    thdraw (-.2u,.2u)--(.1u,.2u);\n"
"    thdraw (-.15u,0)--(.15u,0);\n"
"    thdraw (-.1u,-.2u)--(.2u,-.2u);\n"
"enddef;\n"
"\n"
"def p_bridge_SKBB (expr pos,r,s,al) = \n"
"    U:=(.4u, .4u);\n"
"    T:=identity aligned al shifted pos;\n"
"    thdraw unitsquare scaled .8u shifted (-0.4u,-.4u) withpen PenD;\n"
"    pickup PenC;\n"
"    thdraw (-.3u,.2u)--(-.2u,.1u)--(.2u,.1u)--(.3u,.2u);\n"
"    thdraw (-.3u,-.2u)--(-.2u,-.1u)--(.2u,-.1u)--(.3u,-.2u);\n"
"enddef;\n"
"\n"
"def p_noequipment_SKBB (expr pos,r,s,al) = \n"
"    U:=(.4u, .4u);\n"
"    T:=identity aligned al shifted pos;\n"
"    thdraw unitsquare scaled .8u shifted (-0.4u,-.4u) withpen PenD;\n"
"    thfill (0,-.1u)--(-.05u,.3u)--(.05u,.3u)--cycle;\n"
"    thdraw (0,-.2u) withpen PenX;\n"
"enddef;\n"
"\n"
"def p_anchor_SKBB (expr pos,r,s,al) = \n"
"    U:=(.4u, .4u);\n"
"    T:=identity aligned al shifted pos;\n"
"    thdraw unitsquare scaled .8u shifted (-0.4u,-.4u) withpen PenD;\n"
"    thdraw fullcircle scaled .2u shifted (0.2u,0) withpen PenC;\n"
"    begingroup;\n"
"      interim linecap:=butt;\n"
"      thdraw (-.3u,0)--(.1u,0) withpen PenA;\n"
"    endgroup;\n"
"    thdraw (.1u,-.4u)--(.1u,.4u) withpen PenD;\n"
"enddef;\n"
"\n"
"def p_traverse_SKBB (expr pos,r,s,al) = \n"
"    U:=(.4u, .4u);\n"
"    T:=identity aligned al shifted pos;\n"
"    thdraw unitsquare scaled .8u shifted (-0.4u,-.4u) withpen PenD;\n"
"    pickup PenC;\n"
"    thdraw (-.25u,.05u)..(0,-.08u)..(.25u,.05u);\n"
"    pickup pencircle scaled .18u;\n"
"    thdraw (-.25u,.05u);\n"
"    thdraw (.25u,.05u);\n"
"enddef;\n"
"\n"
"def p_rope_SKBB (expr pos,r,s,al) = \n"
"    U:=(.4u, .4u);\n"
"    T:=identity aligned al shifted pos;\n"
"    thdraw unitsquare scaled .8u shifted (-0.4u,-.4u) withpen PenD;\n"
"    pickup PenC;\n"
"    thdraw (-.2u,.2u)..origin..(.1u,.1u)--(.1u,-.4u);\n"
"    pickup pencircle scaled .18u;\n"
"    thdraw (-.2u,.2u);\n"
"    thdraw (.1u,.1u);\n"
"enddef;\n"
"\n"
"def p_camp_SKBB (expr pos,r,s,al) = \n"
"    U:=(.4u, .5u);\n"
"    T:=identity aligned al shifted pos;\n"
"    pickup PenC;\n"
"    thdraw (-.4u,-.4u)--(0,.5u)--(.4u,-.4u)--cycle;\n"
"    pickup PenD;\n"
"    thdraw (0,-.4u)--(0,.5u);\n"
"enddef;\n"
"\n"
"\n"
"def p_dig_UIS (expr pos,r,s,al) = \n"
"    U:=(.4u, .5u);\n"
"    T:=identity aligned al shifted pos;\n"
"    thfill ((-.075u,-.5u){down} .. {up}(0.075u, -.5u) -- (0.075u, .15u) -- (0.3u, 0.15u) -- (0.3u, 0.5u) --\n"
"    (-.3u, .5u) -- (-.3u, .15u) -- (-.075u, .15u) -- cycle) rotated 45;\n"
"enddef;\n"
"\n"
"def p_continuation_UIS(expr pos,theta,sc,al) =\n"
"  U:=(.15u,.3u);\n"
"  T:=identity aligned al shifted pos;\n"
"  pickup PenC;\n"
"  thdraw (-.1u,.2u){up}..{down}(.1u,.2u)..{down}(0,-.05u);\n"
"  pickup PenX;\n"
"  thdraw (0,-.2u);\n"
"enddef;\n"
"\n"
"def p_station_SKBB(expr pos,mark,txt)(text flags) =\n"
"  T:=identity shifted pos;\n"
"\n"
"  if mark=4: p_station_fixed(pos)\n"
"  elseif mark=3: p_station_natural(pos)\n"
"  elseif mark=2: p_station_painted(pos)\n"
"  elseif mark=1: p_station_temporary(pos)\n"
"  fi;\n"
"  \n"
"  path path_cave;\n"
"  path_cave = (-.3u,-.25u) -- (-.2u,-.25u){dir 135} .. (0, .25u) .. {dir 225}(.2u,-.25u) -- (.3u,-.25u);\n"
"  for i=flags:\n"
"    pickup PenX;\n"
"    if i=\"entrance\":\n"
"%      thfill fullcircle scaled 1 cm withtransparentcolor tr_blue;\n"
"      thdraw path_cave;\n"
"%      p_label.urt(txt,pos+(0.4u,0),0,0);\n"
"      if not numeric txt:\n"
"        p_smartlabel(txt,pos);\n"
"      fi;\n"
"    elseif i=\"sink\":\n"
"      thdraw path_cave cutbefore ((-u,0)--(u,0)) cutafter ((-u,0)--(u,0));\n"
"      pickup PenA;\n"
"      thdraw (0,-.45u) -- (0,.05u) withcolor blue;\n"
"      thdraw (-.15u,-.02u) -- (0,.05u) -- (.15u,-.02u) withcolor blue;\n"
"    elseif i=\"spring\":\n"
"      thdraw path_cave cutbefore ((-u,0)--(u,0)) cutafter ((-u,0)--(u,0));\n"
"      pickup PenA;\n"
"      thdraw (0,-.45u) -- (0,.05u) withcolor blue;\n"
"      thdraw (-.15u,-.38u) -- (0,-.45u) -- (.15u,-.38u) withcolor blue;\n"
"    elseif i=\"doline\":\n"
"      thdraw (-.5u,.05u){down}..(0,-0.6u)..{up}(.5u,.05u);\n"
"    elseif i=\"dig\":\n"
"      thdraw (-.5u,.25u) -- (-.35u,.25u)--(-.23u,-.25u)--(.23u,-.25u)--(.35u,.25u)--(.5u,.25u);\n"
"    elseif substring(0,11) of i = \"air-draught\":\n"
"      pickup PenB;\n"
"      thdraw ((0,.11u){dir-120} ..{dir-70}(0,0) .. {dir-120}(0,-.11u));\n"
"      thdraw ((0,.11u){dir-120} ..{dir-70}(0,0) .. {dir-120}(0,-.11u)) shifted (.11u,0);\n"
"      thdraw ((0,.11u){dir-120} ..{dir-70}(0,0) .. {dir-120}(0,-.11u)) shifted (-.11u,0);\n"
"    elseif i=\"continuation\":\n"
"      if picture(txt):\n"
"        picture ATTR__text;\n"
"        ATTR__text := txt;\n"
"      fi;\n"
"      begingroup;\n"
"        save T; transform T;\n"
"        p_continuation(pos+(0,.25u),0,1,(0,1));\n"
"      endgroup;\n"
"      if picture(txt):\n"
"        save ATTR__text;\n"
"      fi;\n"
"    elseif i=\"arch\":\n"
"      thdraw (-.5u,-.25u)--(-.5u,.25u)--(.5u,.25u)--(.5u,-.25u)..(0,.2u)..cycle;\n"
"      thfill (-.5u,-.25u)--(-.5u,.25u)--(.5u,.25u)--(.5u,-.25u)..(0,.2u)..cycle;\n"
"    elseif i=\"overhang\":\n"
"      thdraw (.2u,-.25u)--(-.2u,-.25u){up}..{right}(.2u,.25u);\n"
"    fi;\n"
"  endfor;\n"
"%  thdraw (0,0) withpen PenX withcolor red;\n"
"enddef;\n"
"\n"
"def p_debug (expr col, pen, pos)=\n"
"    T:=identity shifted pos;\n"
"    thdraw origin withpen pencircle \n"
"      scaled if pen=0: 2pt \n"
"                 else: 4pt fi \n"
"      withcolor if col=-2: (1,.85,0)\n"
"           elseif col=-1: black \n"
"           elseif col=0: red \n"
"           else: blue fi;\n"
"enddef;\n"
"\n"
"\n"
"def p_u(expr pos,theta,sc,al) =\n"
"  T:=identity shifted pos;\n"
"  thdraw origin withpen pencircle scaled 4pt withcolor red;\n"
"enddef;\n"
"\n"
"def p_handrail_SKBB(expr pos,theta,sc,al) =\n"
"    tmph := 1 / Scale * 72 / 2.54;  % 1 m height\n"
"    U:=(.1u, tmph);\n"
"    pickup PenC;\n"
"    T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"    thdraw (0,0) -- (0,tmph);\n"
"    thdraw (0,tmph) withpen pencircle scaled .25u;    \n"
"enddef;\n"
"\n"
"def p_viaferrata_SKBB(expr pos,r,s,al) = \n"
"    U:=(.4u, .4u);\n"
"    T:=identity aligned al shifted pos;\n"
"    thdraw unitsquare scaled .8u shifted (-0.4u,-.4u) withpen PenD;\n"
"    pickup PenC;\n"
"    thdraw (-.15u,.15u)--(-.15u,.1u)--(.15u,.1u)--(.15u,.15u);\n"
"    thdraw (-.15u,-.05u)--(-.15u,-.1u)--(.15u,-.1u)--(.15u,-.05u);\n"
"enddef;\n"
"\n"
"def p_stalagmites_UIS(expr pos,theta,sc,al) =\n"
"    U:=(.3u, .2u);\n"
"    T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"    pickup PenC;\n"
"    for i=-1 upto 1:\n"
"        T:=identity aligned al rotated theta scaled (sc * 0.7) shifted (pos + (i * .3u, 0));\n"
"        thdraw (0,.4u) -- (0,-.15u) -- (-.15u,-.4u);\n"
"        thdraw (0,-.15u) -- (.15u,-.4u);\n"
"    endfor;\n"
"enddef;\n"
"\n"
"def p_stalactites_UIS(expr pos,theta,sc,al) =\n"
"    U:=(.3u, .2u);\n"
"    pickup PenC;\n"
"    for i=-1 upto 1:\n"
"        T:=identity aligned al rotated theta scaled (sc * 0.7) shifted (pos + (i * .3u, 0));\n"
"        thdraw (0,-.4u) -- (0,.15u) -- (-.15u,.4u);\n"
"        thdraw (0,.15u) -- (.15u,.4u);\n"
"    endfor;\n"
"enddef;\n"
"\n"
"def p_gradient_SKBB (expr pos,theta,sc,al)=\n"
"    U:=(.3u,.6u);\n"
"    T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"    pickup PenC;\n"
"    thdraw (-.3u,-.6u)--(-.3u,.6u);\n"
"    thdraw (0,-.6u)--(0,-0.2u);\n"
"    thdraw (.3u,-.6u)--(.3u,.6u);\n"
"enddef;\n"
"\n"
"def p_pillars_UIS(expr pos,theta,sc,al) =\n"
"    U:=(.3u, .2u);\n"
"    T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"    pickup PenC;\n"
"    for i=-1 upto 1:\n"
"        T:=identity aligned al rotated theta scaled (sc * 0.7) shifted (pos + (i * .3u, 0));\n"
"        thdraw (0,.15u)--(0,-.15u);\n"
"        thdraw (-.15u,-.4u)--(0,-.15u)--(.15u,-.4u);\n"
"        thdraw (-.15u,.4u)--(0,.15u)--(.15u,.4u);\n"
"    endfor;\n"
"enddef;\n"
"\n"
"\n"
"\n\n\n%%%%% ENDINPUT thPoint %%%%%\n\n\n"
"\n\n\n%%%%% INPUT thLine %%%%%\n\n\n"
"%% therion source code\n"
"%%\n"
"%% This file defines macros for line symbols\n"
"%%\n"
"%% $Date: 2003/07/01 09:06:44 $\n"
"%% $RCSfile: thLine.mp,v $\n"
"%% $Revision: 1.4 $\n"
"%%\n"
"%% Copyright (C) 2000 Martin Budaj\n"
"%%\n"
"%% -------------------------------------------------------------------- \n"
"%% This program is free software; you can redistribute it and/or modify\n"
"%% it under the terms of the GNU General Public License as published by\n"
"%% the Free Software Foundation; either version 2 of the License, or\n"
"%% any later version.\n"
"%%\n"
"%% This program is distributed in the hope that it will be useful,\n"
"%% but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
"%% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n"
"%% GNU General Public License for more details.\n"
"%% \n"
"%% You should have received a copy of the GNU General Public License\n"
"%% along with this program; if not, write to the Free Software\n"
"%% Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n"
"%% --------------------------------------------------------------------\n"
"\n"
"% some definitions\n"
"\n"
"% adjust step according to the length of the path; return at least two steps\n"
"\n"
"vardef adjust_step (expr len, s) =\n"
"  if s <= len/2: len / (floor(len / s))\n"
"  else: len/2 fi\n"
"enddef;\n"
"\n"
"def mark_(expr p,t,l) =\n"
"  thdraw (point t of p) --\n"
"          ((point t of p) + l * unitvector(thdir(p,t) rotated 90));\n"
"enddef;\n"
"\n"
"vardef thdir (expr p,t) =    % 1 * epsilon caused problems in scales < 1:1000\n"
"                             % n * epsilon is enough for scale 1:(n*1000)\n"
"  if arclength(p)=0:\n"
"    hide(thwarning(\"unable to determine direction on zero-length path\"))\n"
"    (0,1)\n"
"  else:\n"
"%  ((direction t-100*epsilon of p) + (direction t+100*epsilon of p)) / 2\n"
"   postcontrol (t+1000*epsilon) of p - precontrol (t-1000*epsilon) of p\n"
"%  direction t of p\n"
"  fi\n"
"enddef;\n"
"\n"
"% walls:\n"
"\n"
"def l_wall_bedrock_UIS (expr P) = \n"
"  T:=identity;\n"
"  pickup PenA;\n"
"  thdraw P;\n"
"enddef;\n"
"\n"
"def l_wall_sand_SKBB (expr P) = \n"
"  T:=identity;\n"
"  cas := 0;\n"
"  dlzka := arclength P;\n"
"  mojkrok:=adjust_step(dlzka, 0.1u);\n"
"  pickup PenB;  \n"
"  forever:\n"
"    t := arctime cas of P;\n"
"    thdraw ((point t of P) + (uniformdeviate 1) * .4u \n"
"            * unitvector(thdir(P,t) rotated -90));\n"
"    cas := cas + mojkrok;\n"
"    exitif cas > dlzka + (mojkrok / 3); % for rounding errors\n"
"  endfor;\n"
"  pickup PenA;  \n"
"  thdraw P;\n"
"enddef;\n"
"\n"
"def l_wall_pebbles_SKBB (expr P) = \n"
"  T:=identity;\n"
"  cas := 0;\n"
"  dlzka := arclength P;\n"
"  mojkrok:=adjust_step(dlzka, .35u);\n"
"  pickup PenC;\n"
"  q:=superellipse((.2u,0),(0,.1u),(-.2u,0),(0,.-.1u),.75);\n"
"  forever:\n"
"    t := arctime (cas + mojkrok/2) of P;\n"
"    thdraw q randomized (u/20) rotated (angle(thdir(P,t)) + (normaldeviate*40)) shifted point t of P;\n"
"    cas := cas + mojkrok;\n"
"    exitif cas > dlzka - (2*mojkrok/3); % for rounding errors\n"
"  endfor;\n"
"enddef;\n"
"\n"
"def l_wall_clay_SKBB (expr P) = \n"
"  T:=identity;\n"
"  cas := 0;\n"
"  dlzka := arclength P;\n"
"  mojkrok:=adjust_step(dlzka, .5u);\n"
"  pickup PenC;\n"
"  q := (-0.15u,0){up}..{down}origin..{up}(0.15u,0);\n"
"  forever:\n"
"    t := arctime (cas + mojkrok/2) of P;\n"
"    thdraw q shifted (point t of P + .25u * unitvector(thdir(P,t) rotated -90));\n"
"    cas := cas + mojkrok;\n"
"    exitif cas > dlzka - (2*mojkrok/3); % for rounding errors\n"
"  endfor;\n"
"  pickup PenA;  \n"
"  thdraw P;\n"
"enddef;\n"
"\n"
"def l_wall_debris_SKBB (expr P) = \n"
"  T:=identity;\n"
"  cas := 0;\n"
"  dlzka := arclength P;\n"
"  mojkrok:=adjust_step(dlzka, .4u);\n"
"  pickup PenC;\n"
"%  q := ((-.1u,-.15u)--(.2,.03u)--(-.2u,.15u)--cycle) scaled 1.5;\n"
"  q := ((-.2u,-.1u)--(.2u,-.1u)--(0,.2u)--cycle) scaled 1.1;\n"
"  forever:\n"
"    t := arctime (cas + mojkrok/2) of P;\n"
"    thdraw q randomized (u/10) rotated uniformdeviate (360) shifted point t of P;\n"
"    cas := cas + mojkrok;\n"
"    exitif cas > dlzka - (2*mojkrok/3); % for rounding errors\n"
"  endfor;\n"
"enddef;\n"
"\n"
"def l_wall_blocks_SKBB (expr P) = \n"
"%  pickup PenD;\n"
"%  draw P withcolor red;\n"
"\n"
"  T:=identity;\n"
"  cas := 0;\n"
"  dlzka := arclength P;\n"
"if dlzka > 0:\n"
"  mojkrok:=adjust_step(dlzka, 1.5u);\n"
"  pickup PenA;\n"
"  forever:\n"
"    t1 := arctime (cas + mojkrok*1/10) of P;\n"
"    t2 := arctime (cas + mojkrok*9/10) of P;\n"
"    q := ((point t1 of P) + .4u * unitvector(thdir(P,t1) rotated -90)) --\n"
"         (subpath (t1,t2) of P) --\n"
"         ((point t2 of P) + .4u * unitvector(thdir(P,t2) rotated -90));\n"
"    thdraw q randomized (u/6);\n"
"    cas := cas + mojkrok;\n"
"    exitif cas > dlzka - (2*mojkrok/3); % for rounding errors\n"
"  endfor;\n"
"fi;\n"
"enddef;\n"
"\n"
"def l_wall_ice_SKBB (expr P) = \n"
"  T:=identity;\n"
"  cas := 0;\n"
"  dlzka := arclength P;\n"
"  mojkrok:=adjust_step(dlzka, .5u);\n"
"  pickup PenC;\n"
"  p := (-.1u,0)--(.1u,0);\n"
"  q := (0,-.1u)--(0,.1u);\n"
"  forever:\n"
"    t := arctime (cas + mojkrok/2) of P;\n"
"    thdraw p shifted (point t of P + .25u * unitvector(thdir(P,t) rotated -90));\n"
"    thdraw q shifted (point t of P + .25u * unitvector(thdir(P,t) rotated -90));\n"
"    cas := cas + mojkrok;\n"
"    exitif cas > dlzka - (2*mojkrok/3); % for rounding errors\n"
"  endfor;\n"
"  pickup PenA;  \n"
"  thdraw P;\n"
"enddef;\n"
"\n"
"def l_wall_underlying_UIS (expr P) = \n"
"  T:=identity;\n"
"  pickup PenA;\n"
"  thdraw P dashed evenly scaled optical_zoom;\n"
"enddef;\n"
"\n"
"def l_wall_unsurveyed_SKBB (expr P) = \n"
"  T:=identity;\n"
"  pickup PenC;\n"
"  thdraw P;\n"
"enddef;\n"
"\n"
"def l_wall_presumed_UIS (expr P) = \n"
"  T:=identity;\n"
"  pickup PenA;\n"
"  thdraw P dashed evenly scaled (2*optical_zoom);\n"
"enddef;\n"
"\n"
"% other line symbols\n"
"\n"
"def l_pit_UIS (expr P) = \n"
"  T:=identity;\n"
"  cas := 0;\n"
"  dlzka := arclength P;\n"
"  mojkrok:=adjust_step(dlzka, 0.25u);\n"
"  pickup PenD;  \n"
"  forever:\n"
"    t := arctime cas of P;\n"
"    mark_ (P,t,0.2u);\n"
"    cas := cas + mojkrok;\n"
"    exitif cas > dlzka + (mojkrok / 3); % for rounding errors\n"
"  endfor;\n"
"  pickup PenC;  \n"
"  thdraw P;\n"
"enddef;\n"
"\n"
"let l_floorstep_UIS = l_pit_UIS;\n"
"\n"
"def l_overhang_SKBB (expr P) =\n"
"  T:=identity;\n"
"  cas := 0;\n"
"  dlzka := arclength P;\n"
"  mojkrok:=adjust_step(dlzka, 0.3u);\n"
"  pickup PenC;\n"
"  t1:=0;\n"
"  forever:\n"
"    t := arctime (cas + mojkrok/2) of P;\n"
"    t2 := arctime (cas + mojkrok) of P;\n"
"    thfill (subpath (t1,t2) of P) -- \n"
"      ((point t of P) + .3u * unitvector(thdir(P,t) rotated 90)) -- \n"
"      cycle;\n"
"    cas := cas + mojkrok;\n"
"    exitif cas > dlzka - (2*mojkrok/3); % for rounding errors\n"
"    t1:=t2;\n"
"  endfor;\n"
"  thdraw P;\n"
"enddef;\n"
"\n"
"\n"
"def l_chimney_UIS (expr P) = \n"
"  T:=identity;\n"
"  pickup PenC;\n"
"  thdraw P dashed evenly scaled optical_zoom;\n"
"enddef;\n"
"\n"
"def l_ceilingstep_SKBB (expr P) =\n"
"  T:=identity;\n"
"  cas := 0;\n"
"  dlzka := arclength P;\n"
"  mojkrok:=adjust_step(dlzka, 0.8u);\n"
"  pickup PenC;\n"
"  forever:\n"
"    t1 := arctime (cas + mojkrok*1/5) of P;\n"
"    t  := arctime (cas + mojkrok/2) of P;\n"
"    t2 := arctime (cas + mojkrok*4/5) of P;\n"
"    thdraw (subpath (t1,t2) of P);\n"
"    mark_ (P,t,0.2u);\n"
"    cas := cas + mojkrok;\n"
"    exitif cas > dlzka - (2*mojkrok/3); % for rounding errors\n"
"  endfor;\n"
"enddef;\n"
"\n"
"def l_ceilingmeander_SKBB (expr P) =\n"
"  pair Pp;\n"
"  pair Pd;\n"
"  pair Pv;\n"
"  T:=identity;\n"
"  cas := 0;\n"
"  dlzka := arclength P;\n"
"  mojkrok:=adjust_step(dlzka, 0.8u);\n"
"  pickup PenC;\n"
"  forever:\n"
"    t  := arctime (cas + mojkrok/2) of P;\n"
"    Pp := (point t of P);\n"
"    Pd := unitvector(thdir(P,t));\n"
"    Pv := Pd rotated 90;\n"
"    thdraw (Pp + 0.1u * Pv) --\n"
"          (Pp + 0.2u * Pv);\n"
"    thdraw (Pp + 0.2u * Pv + 0.2u * Pd) --\n"
"          (Pp + 0.2u * Pv - 0.2u * Pd);\n"
"    thdraw (Pp - 0.1u * Pv) --\n"
"          (Pp - 0.2u * Pv);\n"
"    thdraw (Pp - 0.2u * Pv + 0.2u * Pd) --\n"
"          (Pp - 0.2u * Pv - 0.2u * Pd);\n"
"    cas := cas + mojkrok;\n"
"    exitif cas > dlzka - (2*mojkrok/3); % for rounding errors\n"
"  endfor;\n"
"enddef;\n"
"\n"
"\n"
"%Bruce Mutton 2012.06.16 uses general code for l_ceilingmeander_SKBB defined in therion source code by Martin Budaj 5.3.9\n"
"% but ticks on outside (rock) side of lines \n"
"def l_ceilingmeander_UIS (expr P) =\n"
"  pair Pp;\n"
"  pair Pd;\n"
"  pair Pv;\n"
"  T:=identity;\n"
"  cas := 0;                           % cursor to step along path\n"
"  dlzka := arclength P;\n"
"  mojkrok:=adjust_step(dlzka, 0.8u);  % symbol length nudged to be multiple of path length\n"
"  pickup PenC;\n"
"  forever:\n"
"    t  := arctime (cas + mojkrok/2) of P;\n"
"    Pp := (point t of P);\n"
"    Pd := unitvector(thdir(P,t));\n"
"    Pv := Pd rotated 90;\n"
"    thdraw (Pp + 0.2u * Pv) --\n"
"          (Pp + 0.3u * Pv);              % add 0.1u to each moves ticks outside\n"
"    thdraw (Pp + 0.2u * Pv + 0.2u * Pd) --\n"
"          (Pp + 0.2u * Pv - 0.2u * Pd);  \n"
"    thdraw (Pp - 0.2u * Pv) --\n"
"          (Pp - 0.3u * Pv);              % subtract 0.1u to each moves ticks outside\n"
"    thdraw (Pp - 0.2u * Pv + 0.2u * Pd) --\n"
"          (Pp - 0.2u * Pv - 0.2u * Pd); \n"
"    cas := cas + mojkrok;\n"
"    exitif cas > dlzka - (2*mojkrok/3);  % for rounding errors\n"
"  endfor;\n"
"enddef;\n"
"\n"
"let l_ceilingmeander_NZSS = l_ceilingmeander_UIS;\n"
"\n"
"%Bruce Mutton 2012.06.16 uses general code for l_ceilingstep_SKBB defined in therion source code by Martin Budaj 5.3.9\n"
"% but ticks on righthand (rock) side of line \n"
"def l_ceilingstep_UIS (expr P) =\n"
"  T:=identity;\n"
"  cas := 0;                            % cursor to step along path\n"
"  dlzka := arclength P;\n"
"  mojkrok:=adjust_step(dlzka, 0.8u);   % symbol length nudged to be multiple of path length\n"
"  pickup PenC;\n"
"  forever:\n"
"    t1 := arctime (cas + mojkrok*1/5) of P;\n"
"    t  := arctime (cas + mojkrok/2) of P;\n"
"    t2 := arctime (cas + mojkrok*4/5) of P;\n"
"    thdraw (subpath (t1,t2) of P);\n"
"    mark_ (P,t,-0.2u);                  % change sign to -0.2u\n"
"    cas := cas + mojkrok;\n"
"    exitif cas > dlzka - (2*mojkrok/3); % for rounding errors\n"
"  endfor;\n"
"enddef;\n"
"\n"
"let l_ceilingstep_NZSS = l_ceilingstep_UIS;\n"
"\n"
"%Bruce Mutton 2012.06.10 uses general code for l_pit_UIS defined in therion source code by Martin Budaj 5.3.9\n"
"% dots on righthand (rock) side of line spaced 0.2u, 0.2u same as floor-step ticks\n"
"def l_chimney_NZSS (expr P) = \n"
"\tT:=identity;\n"
"\tcas := 0;                            % cursor to step along path\n"
"\tdlzka := arclength P;\n"
"\tmojkrok:=adjust_step(dlzka, 0.25u);  % symbol length nudged to be multiple of path length\n"
"\tq:= (0.20u,-0.20u) -- (0.21u,-0.21u);         % dot\n"
"\n"
"\tpickup PenC;  %2nd thinnest pen\n"
"\tforever:\n"
"\t  t := arctime cas of P;\n"
"\tthdraw q rotated angle(thdir(P,t)) shifted (point t of P ); % draw dots\n"
"\tcas := cas + mojkrok;\n"
"\t  exitif cas > dlzka + (mojkrok / 3); % for rounding errors\n"
"\tendfor;\n"
"\tpickup PenB;   %2nd thickest pen\n"
"\tthdraw P;      %continuous line\n"
"enddef;\n"
"\n"
"%Bruce Mutton 2010.06.20 uses general code and adjust_step defined in therion source code by Martin Budaj\n"
"%for Therion 5.3.8\n"
"def l_wall_presumed_NZSS (expr P) =\n"
"\tT:=identity;\n"
"\tcas := 0;                                 % cursor to step along path\n"
"\tdlzka := arclength P;\n"
"\tmojkrok:=adjust_step(dlzka, 1.5u);        % symbol length nudged to be multiple of path length\n"
"\tq  := (-0.2u,-0.4u)--(0,0)--(0.2u,-0.4u); % define v shape \n"
"\tforever:\n"
"\t  t1 := arctime (cas + mojkrok*1/5) of P;\n"
"\t  t  := arctime (cas + mojkrok/2) of P;\n"
"\t  t2 := arctime (cas + mojkrok*4/5) of P;\n"
"\t\tpickup PenA;                          % thick\n"
"\tthdraw (subpath (t1,t2) of P);          % dash\n"
"\t  pickup PenC;                          % thin\n"
"\t  thdraw q rotated angle(thdir(P,t)) shifted (point t of P ); % v shape\n"
"\n"
"\t  cas := cas + mojkrok;\n"
"\t  exitif cas > dlzka - (2*mojkrok/3);     % for rounding errors\n"
"\tendfor;\n"
"enddef;\n"
"\n"
"def l_floormeander_SKBB (expr P) =\n"
"  pair Pp;\n"
"  pair Pd;\n"
"  pair Pv;\n"
"  pair PPp;\n"
"  pair PPd;\n"
"  pair PPv;\n"
"\n"
"  T:=identity;\n"
"  cas := 0;\n"
"  dlzka := arclength P;\n"
"  mojkrok:=adjust_step(dlzka, 0.25u);\n"
"  pickup PenC;\n"
"  forever:\n"
"    t := arctime cas of P;\n"
"    Pp := (point t of P);\n"
"    Pd := unitvector(thdir(P,t));\n"
"    Pv := Pd rotated 90;\n"
"    thdraw (Pp + 0.1u * Pv) --\n"
"          (Pp + 0.2u * Pv);\n"
"    thdraw (Pp - 0.1u * Pv) --\n"
"          (Pp - 0.2u * Pv);\n"
"    if cas > 0:\n"
"      thdraw (PPp + 0.2u * PPv) --\n"
"          (Pp + 0.2u * Pv);\n"
"      thdraw (PPp - 0.2u * PPv) --\n"
"          (Pp - 0.2u * Pv);\n"
"    fi;\n"
"    PPp := Pp;\n"
"    PPd := Pd;\n"
"    PPv := Pv;\n"
"    cas := cas + mojkrok;\n"
"    exitif cas > dlzka + (mojkrok / 3); % for rounding errors\n"
"  endfor;\n"
"enddef;    \n"
"\n"
"boolean alw_perpendicular;\n"
"\n"
"def l_slope_SKBB (expr P,S)(text Q) = \n"
"%show Q;\n"
"  T:=identity;\n"
"  numeric dirs[];\n"
"  numeric lengths[];\n"
"  for i=Q:\n"
"    dirs[redpart i]:=greenpart i;\n"
"    lengths[redpart i]:=bluepart i;\n"
"  endfor;  \n"
"\n"
"\n"
"  li:=length(P); % last\n"
"\n"
"  alw_perpendicular:=true;\n"
"\n"
"  for i=0 upto li:\n"
"    if unknown dirs[i]: dirs[i]:=-1; \n"
"    else: \n"
"      if dirs[i]>-1:\n"
"        dirs[i]:=((90-dirs[i]) - angle(thdir(P,i))) mod 360; \n"
"        alw_perpendicular:=false;\n"
"      fi;\n"
"    fi;\n"
"    if unknown lengths[i]: lengths[i]:=-1; fi;\n"
"  endfor;\n"
"\n"
"%for i=0 upto li: show dirs[i]; endfor;\n"
"\n"
"  ni:=0; % next\n"
"  pi:=0; % previous\n"
"\n"
"  for i=0 upto li:\n"
"    d:=dirs[i];\n"
"    if d=-1:\n"
"      if (i=0) or (i=li):\n"
"        dirs[i] := angle(thdir(P,i) rotated 90) mod 360;\n"
"\tpi:=i;\n"
"      else:\n"
"        if ni<=i:\n"
"\t  for j=i upto li:\n"
"            ni:=j;\n"
"\t    exitif dirs[j]>-1;\n"
"\t  endfor;\n"
"\tfi;\n"
"\tw:=arclength(subpath(pi,i) of P) / \n"
"\t   arclength(subpath(pi,ni) of P);\n"
"\tdirs[i]:=w[dirs[pi],dirs[ni]];\n"
"%        if (dirs[i]-angle(thdir(P,i))) mod 360>180:\n"
"%          dirs[i]:=w[dirs[ni],dirs[pi]];\n"
"%\t  message(\"*******\");\n"
"%        fi;\n"
"     fi;\n"
"    else:\n"
"      pi:=i;\n"
"    fi;\n"
"  endfor;\n"
"\n"
"%for i=0 upto li: show dirs[i]; endfor;\n"
"\n"
"  ni:=0; % next\n"
"  pi:=0; % previous\n"
"\n"
"  for i=0 upto li:\n"
"    l:=lengths[i];\n"
"    if l=-1:\n"
"      if (i=0) or (i=li):\n"
"        lengths[i] := 1cm; % should never happen!\n"
"\tthwarning(\"slope width at the end point not specified\");\n"
"\tpi:=i;\n"
"      else:\n"
"        if ni<=i:\n"
"\t  for j=i+1 upto li:\n"
"            ni:=j;\n"
"\t    exitif lengths[j]>-1;\n"
"\t  endfor;\n"
"\tfi;\n"
"\tw:=arclength(subpath(pi,i) of P) / \n"
"\t   arclength(subpath(pi,ni) of P);\n"
"\tlengths[i]:=w[lengths[pi],lengths[ni]];\n"
"\tpi:=i;\n"
"      fi;\n"
"    else:\n"
"      pi:=i;\n"
"    fi;\n"
"  endfor;\n"
"\n"
"% for i=0 upto li: show lengths[i]; endfor;\n"
"\n"
"  T:=identity;\n"
"  boolean par;\n"
"  offset:=0;\n"
"  dlzka := (arclength P);\n"
"  if dlzka>3u: \n"
"    offset := 0.3u;\n"
"  elseif dlzka>u:\n"
"    offset := 0.1u;\n"
"  fi;\n"
"  dlzka:=dlzka-2offset;\n"
"  cas := offset;\n"
"  mojkrok:=adjust_step(dlzka,1.4u) / 2;\n"
"  pickup PenD;\n"
"  par := false; \n"
"  forever:\n"
"    t := arctime cas of P;\n"
"    if t mod 1>0:  % not a key point\n"
"      w := (arclength(subpath(floor t,t) of P) / \n"
"            arclength(subpath(floor t,ceiling t) of P));\n"
"      if alw_perpendicular:\n"
"        a := 90;\n"
"      else:\n"
"        a := w[dirs[floor t],dirs[ceiling t]];\n"
"      fi;\n"
"      l := w[lengths[floor t],lengths[ceiling t]];\n"
"    else:\n"
"      if alw_perpendicular:\n"
"        a := 90;\n"
"      else:\n"
"        a:= dirs[t];\n"
"      fi; \n"
"      l:=lengths[t];\n"
"    fi;\n"
"    \n"
"    a := a + angle(thdir(P,t));\n"
"    \n"
"    thdraw (point t of P) -- \n"
"      ((point t of P) + if par: 0.333 * fi l * unitvector(dir(a)));\n"
"    cas := cas + mojkrok;\n"
"    par := not par;\n"
"    exitif cas > dlzka + offset + 0.1mm;  % for rounding errors\n"
"  endfor;\n"
"  if S = 1: pickup PenC; draw P fi;\n"
"%pickup pencircle scaled 3pt;\n"
"%for i=0 upto li: draw point i of P; endfor;\n"
"enddef;\n"
"\n"
"\n"
"def l_slope_BCRA (expr P,S)(text Q) = \n"
"%show Q;\n"
"  T:=identity;\n"
"  numeric dirs[];\n"
"  numeric lengths[];\n"
"  for i=Q:\n"
"    dirs[redpart i]:=greenpart i;\n"
"    lengths[redpart i]:=bluepart i;\n"
"  endfor;  \n"
"\n"
"\n"
"  li:=length(P); % last\n"
"\n"
"  alw_perpendicular:=true;\n"
"\n"
"  for i=0 upto li:\n"
"    if unknown dirs[i]: dirs[i]:=-1; \n"
"    else: \n"
"      if dirs[i]>-1:\n"
"        dirs[i]:=((90-dirs[i]) - angle(thdir(P,i))) mod 360; \n"
"        alw_perpendicular:=false;\n"
"      fi;\n"
"    fi;\n"
"    if unknown lengths[i]: lengths[i]:=-1; fi;\n"
"  endfor;\n"
"\n"
"%for i=0 upto li: show dirs[i]; endfor;\n"
"\n"
"  ni:=0; % next\n"
"  pi:=0; % previous\n"
"\n"
"  for i=0 upto li:\n"
"    d:=dirs[i];\n"
"    if d=-1:\n"
"      if (i=0) or (i=li):\n"
"        dirs[i] := angle(thdir(P,i) rotated 90) mod 360;\n"
"\tpi:=i;\n"
"      else:\n"
"        if ni<=i:\n"
"\t  for j=i upto li:\n"
"            ni:=j;\n"
"\t    exitif dirs[j]>-1;\n"
"\t  endfor;\n"
"\tfi;\n"
"\tw:=arclength(subpath(pi,i) of P) / \n"
"\t   arclength(subpath(pi,ni) of P);\n"
"\tdirs[i]:=w[dirs[pi],dirs[ni]];\n"
"%        if (dirs[i]-angle(thdir(P,i))) mod 360>180:\n"
"%          dirs[i]:=w[dirs[ni],dirs[pi]];\n"
"%\t  message(\"*******\");\n"
"%        fi;\n"
"     fi;\n"
"    else:\n"
"      pi:=i;\n"
"    fi;\n"
"  endfor;\n"
"\n"
"%for i=0 upto li: show dirs[i]; endfor;\n"
"\n"
"  ni:=0; % next\n"
"  pi:=0; % previous\n"
"\n"
"  for i=0 upto li:\n"
"    l:=lengths[i];\n"
"    if l=-1:\n"
"      if (i=0) or (i=li):\n"
"        lengths[i] := 1cm; % should never happen!\n"
"\tthwarning(\"slope width at the end point not specified\");\n"
"\tpi:=i;\n"
"      else:\n"
"        if ni<=i:\n"
"\t  for j=i+1 upto li:\n"
"            ni:=j;\n"
"\t    exitif lengths[j]>-1;\n"
"\t  endfor;\n"
"\tfi;\n"
"\tw:=arclength(subpath(pi,i) of P) / \n"
"\t   arclength(subpath(pi,ni) of P);\n"
"\tlengths[i]:=w[lengths[pi],lengths[ni]];\n"
"\tpi:=i;\n"
"      fi;\n"
"    else:\n"
"      pi:=i;\n"
"    fi;\n"
"  endfor;\n"
"\n"
"% for i=0 upto li: show lengths[i]; endfor;\n"
"\n"
"  T:=identity;\n"
"  boolean par;\n"
"  offset:=0;\n"
"  dlzka := (arclength P);\n"
"  if dlzka>3u: \n"
"    offset := 0.3u;\n"
"  elseif dlzka>u:\n"
"    offset := 0.1u;\n"
"  fi;\n"
"  dlzka:=dlzka-2offset;\n"
"  cas := offset;\n"
"  mojkrok:=adjust_step(dlzka,1.4u) / 2;\n"
"  pickup PenD;\n"
"  par := false; \n"
"  forever:\n"
"    t := arctime cas of P;\n"
"    if t mod 1>0:  % not a key point\n"
"      w := (arclength(subpath(floor t,t) of P) / \n"
"            arclength(subpath(floor t,ceiling t) of P));\n"
"      if alw_perpendicular:\n"
"        a := 90;\n"
"      else:\n"
"        a := w[dirs[floor t],dirs[ceiling t]];\n"
"      fi;\n"
"      l := w[lengths[floor t],lengths[ceiling t]];\n"
"    else:\n"
"      if alw_perpendicular:\n"
"        a := 90;\n"
"      else:\n"
"        a:= dirs[t];\n"
"      fi; \n"
"      l:=lengths[t];\n"
"    fi;\n"
"    \n"
"    a := a + angle(thdir(P,t));\n"
"    \n"
"    if par:\n"
"      thfill (point t of P) + mojkrok/2.5 * unitvector(dir(a+90))-- \n"
"        ((point t of P) + l * unitvector(dir(a))) --\n"
"        (point t of P) + mojkrok/2.5 * unitvector(dir(a-90)) -- cycle;\n"
"    fi;\n"
"    cas := cas + mojkrok;\n"
"    par := not par;\n"
"    exitif cas > dlzka + offset + 0.1mm;  % for rounding errors\n"
"  endfor;\n"
"enddef;\n"
"\n"
"\n"
"def l_contour_UIS(expr P)(text txt) =\n"
"  T:=identity;\n"
"  pickup PenD;\n"
"  thdraw P;\n"
"  for pnt=txt:\n"
"    if pnt=-2:\n"
"      mark_(P,arctime(arclength(P)/2) of P, 0.2u);\n"
"    elseif pnt>=0:\n"
"      mark_(P,pnt,0.2*u);\n"
"    fi;\n"
"    exitif pnt<0;\n"
"  endfor;\n"
"enddef;\n"
"\n"
"def l_contour_SKBB(expr P)(text txt) =\n"
"  T:=identity;\n"
"  pickup PenD;\n"
"  thdraw P;\n"
"  for pnt=txt:\n"
"    if (pnt=-2) or (pnt=-1):\n"
"      mark_(P,arctime(arclength(P)/2) of P, 0.2u);\n"
"    elseif pnt>=0:\n"
"      mark_(P,pnt,0.2*u);\n"
"    fi;\n"
"    exitif pnt<0;\n"
"  endfor;\n"
"enddef;\n"
"\n"
"def l_rockborder_UIS (expr P) = \n"
"  T:=identity;\n"
"  pickup PenC;\n"
"  if cycle P: thclean P fi;\n"
"  thdraw P;\n"
"enddef;\n"
"\n"
"def l_rockedge_UIS (expr P) = \n"
"  T:=identity;\n"
"  pickup PenD;\n"
"  thdraw P;\n"
"enddef;\n"
"\n"
"def l_border_visible_SKBB (expr Path) =\n"
"  T:=identity;\n"
"  pickup PenC;\n"
"  draw Path;\n"
"enddef;\n"
"\n"
"def l_border_temporary_SKBB (expr Path) =\n"
"  T:=identity;\n"
"  pickup PenC;\n"
"  draw Path dashed evenly scaled optical_zoom;\n"
"enddef;\n"
"\n"
"def l_flowstone_UIS (expr P) = \n"
"  T:=identity;\n"
"  cas := 0;\n"
"  dlzka := arclength P;\n"
"  mojkrok:=adjust_step(dlzka, .7u);\n"
"  if (cycle P) and (dlzka < 3.5u):   % make at least 5 curls on a cyclic path\n"
"    mojkrok := dlzka/5;\n"
"  fi;\n"
"  pickup PenC;  \n"
"  t1:=0;\n"
"  forever:\n"
"    t2 := arctime (cas + mojkrok) of P;\n"
"    thdraw (point t1 of P){dir (angle(thdir(P,t1)) + 60)} ..\n"
"           {dir (angle(thdir(P,t2)) - 60)}(point t2 of P);\n"
"    cas := cas + mojkrok;\n"
"    exitif cas > dlzka + (mojkrok / 3); % for rounding errors\n"
"    t1:=t2;\n"
"  endfor;\n"
"enddef;\n"
"\n"
"\n"
"def l_moonmilk_UIS (expr P) = \n"
"  T:=identity;\n"
"  cas := 0;\n"
"  dlzka := arclength P;\n"
"  mojkrok:=adjust_step(dlzka, .3u);\n"
"  pickup PenC;  \n"
"  t1:=0;\n"
"  forever:\n"
"    t2 := arctime (cas + mojkrok) of P;\n"
"    thdraw (point t1 of P){dir (angle(thdir(P,t1)) + 80)} ..\n"
"           {dir (angle(thdir(P,t2)) - 80)}(point t2 of P);\n"
"    cas := cas + mojkrok;\n"
"    exitif cas > dlzka + (mojkrok / 3); % for rounding errors\n"
"    t1:=t2;\n"
"  endfor;\n"
"enddef;\n"
"\n"
"\n"
"def l_survey_surface_SKBB (expr P) =\n"
"  T:=identity;\n"
"  thdrawoptions(dashed withdots scaled (0.2 * optical_zoom) withpen PenC);\n"
"  thdraw P;\n"
"  thdrawoptions();\n"
"enddef;\n"
"\n"
"def l_survey_cave_SKBB (expr P) =\n"
"  T:=identity;\n"
"  pickup PenC;\n"
"  if ATTR__scrap_centerline:\n"
"    thdraw P;\n"
"  else:\n"
"    PolygonLine:=.8u;\n"
"    pair zz[];\n"
"    for t = 0 upto length P - 1:\n"
"      zz1 := point t of P;\n"
"      zz2 := point t+1 of P;\n"
"      if length (zz2-zz1) > 2*PolygonLine:\n"
"        thdraw zz1 -- zz1 + PolygonLine * unitvector(zz2 - zz1);\n"
"        thdraw zz2 -- zz2 + PolygonLine * unitvector(zz1 - zz2);\n"
"      else:\n"
"        thdraw zz1 -- zz2;\n"
"      fi;\n"
"    endfor;\n"
"  fi;\n"
"enddef;\n"
"\n"
"def l_survey_cave_UIS (expr P) =\n"
"  T:=identity;\n"
"  pair zz[];\n"
"  pickup PenC;\n"
"  for t = 0 upto length P - 1:\n"
"    zz1 := point t of P;\n"
"    zz2 := point t+1 of P;\n"
"    draw zz1 -- zz2;\n"
"  endfor;\n"
"enddef;\n"
"\n"
"def l_waterflow_permanent_UIS (expr Path) =\n"
"  path ppp;\n"
"  T:=identity;\n"
"  cas := 0;\n"
"  dlzka := arclength Path;\n"
"  mojkrok:=adjust_step(dlzka, 0.5u);\n"
"    pickup PenD;  \n"
"    vardef azim = 50 + 15*normaldeviate enddef;\n"
"    az1 := azim;\n"
"    sgn := 1;\n"
"    ppp := point 0 of Path;\n"
"    forever:\n"
"        t1 := arctime cas of Path;\n"
"        t2 := arctime (cas+mojkrok) of Path;\n"
"        if cas+1.1*mojkrok > dlzka:\n"
"            az2 := 0;\n"
"        else:\n"
"            az2 := azim;\n"
"        fi;\n"
"        d1 := angle(thdir(Path,t1)) + sgn * az1;\n"
"        d2 := angle(thdir(Path,t2)) - sgn * az2;\n"
"        ppp := ppp & (point t1 of Path){dir d1} .. {dir d2}(point t2 of Path);\n"
"        az1 := az2;\n"
"        sgn := -1 * sgn;\n"
"        cas := cas + mojkrok;\n"
"        exitif cas > dlzka + mojkrok/3;     % for rounding errors\n"
"    endfor;\n"
"%    drawarrow ppp;\n"
"    thdraw ppp;\n"
"    thdrawoptions();\n"
"    oldahlength:=ahlength;\n"
"    ahlength:=ahlength*optical_zoom;\n"
"    thdraw arrowhead ppp;\n"
"    thfill arrowhead ppp;\n"
"    ahlength:=oldahlength;\n"
"enddef;\n"
"\n"
"def l_waterflow_intermittent_SKBB (expr Path) =\n"
"  thdrawoptions(dashed evenly scaled optical_zoom);\n"
"  l_waterflow_permanent_UIS (Path);\n"
"  thdrawoptions();\n"
"enddef;\n"
"\n"
"def l_waterflow_conjectural_SKBB (expr Path) =\n"
"  thdrawoptions(dashed withdots scaled (0.5 * optical_zoom) withpen PenB);\n"
"  l_waterflow_permanent_UIS (Path);\n"
"  thdrawoptions();\n"
"enddef;\n"
"\n"
"def l_invisible (expr P) = \n"
"enddef;\n"
"\n"
"def l_undefined (expr P) = \n"
"  T:=identity;\n"
"  pickup PenC;\n"
"  thdraw P withcolor red;\n"
"  thwarning(\"undefined line symbol used\");\n"
"enddef;\n"
"\n"
"% Q = 0 -- no arrows\n"
"%     1 -- end\n"
"%     2 -- begin\n"
"%     3 -- both\n"
"\n"
"def l_arrow_SKBB (expr P, Q) =\n"
"  T:=identity;\n"
"  pickup PenC;\n"
"  thdraw P;\n"
"  p := (-.1u,-.25u)--(0,0)--(.1u,-.25u);\n"
"  if odd Q:\n"
"    draw p rotated (angle(thdir(P,0))+90) shifted (point 0 of P);\n"
"  fi;\n"
"  if Q>1:\n"
"    draw p rotated (angle(thdir(P,length P))-90) \n"
"         shifted (point infinity of P);\n"
"  fi;\n"
"enddef;\n"
"\n"
"def l_mapconnection_SKBB (expr P) =\n"
"  thdrawoptions(dashed withdots scaled (0.5 * optical_zoom) withpen PenB);\n"
"  l_arrow_SKBB(P,3);\n"
"  thdrawoptions();\n"
"enddef;\n"
"\n"
"\n"
"def l_section_SKBB (expr P)(text txt) =\n"
"  T:=identity;\n"
"  path Q; Q = punked P;\n"
"  pickup PenC;\n"
"  for t = 0 upto length P - 1:\n"
"    pair zz[];\n"
"    zz1 := point t of P;\n"
"    zz2 := point t+1 of P;\n"
"    zz3 := postcontrol t of P;\n"
"    zz4 := precontrol t+1 of P;\n"
"    if (length(zz3-1/3[zz1,zz2]) > 0.1pt) or\n"
"       (length(zz4-2/3[zz1,zz2]) > 0.1pt):\n"
"      zz5 = whatever[zz1,zz2];\n"
"      (zz3-zz5) = whatever * (zz1-zz2) rotated 90;\n"
"      draw zz1--zz5;\n"
"      zz6 = whatever[zz1,zz2];\n"
"      (zz4-zz6) = whatever * (zz1-zz2) rotated 90;\n"
"      draw zz2--zz6;\n"
"    else:\n"
"      draw zz1--zz2;\n"
"    fi;\n"
"  endfor;\n"
"  for pnt=txt:\n"
"    if pnt=-1:\n"
"    else:\n"
"      T:=identity rotated angle(thdir(Q,pnt)) shifted (point pnt of Q);\n"
"      pickup PenC;\n"
"      thdraw (0,0)--(0,.8u);\n"
"      thdraw (-.1u,.55u)--(0,.8u)--(.1u,.55u);\n"
"    fi;\n"
"    exitif pnt=-1;\n"
"  endfor;\n"
"enddef;\n"
"\n"
"let l_border_invisible = l_invisible;\n"
"let l_wall_invisible = l_invisible;\n"
"\n"
"def l_debug (expr col, pen, P) =\n"
"  T:=identity;\n"
"  pickup if pen=0: PenD else: PenB fi;\n"
"  thdraw P \n"
"    withcolor if col=-2: (1,.85,0)\n"
"          elseif col=-1: black \n"
"           elseif col=0: red \n"
"                   else: blue fi;\n"
"enddef;\n"
"\n"
"\n"
"def l_u (expr P) =\n"
"  T:=identity;\n"
"  pickup PenA;\n"
"  thdraw P withcolor red;\n"
"enddef;\n"
"\n"
"\n"
"def l_gradient_UIS (expr P) =\n"
"  T:=identity;\n"
"  pickup PenC;\n"
"  thdraw P;\n"
"  p:=(-.15u,-.4u)--(0,0)--(.15u,-.4u)--cycle;\n"
"  thfill (p rotated (angle(thdir(P,length P))-90) \n"
"         shifted (point infinity of P));\n"
"  thdraw (p rotated (angle(thdir(P,length P))-90) \n"
"         shifted (point infinity of P));\n"
"enddef;\n"
"\n"
"def l_gradient_BCRA (expr P) =\n"
"  T:=identity;\n"
"  pickup PenC;\n"
"  for t = 0 upto length P - 1:\n"
"    pair zz[];\n"
"    zz1 := point t of P;\n"
"    zz2 := point t+1 of P;\n"
"    zz3 := unitvector(zz2 - zz1);\n"
"    thfill zz1 + u/3 * zz3 + .25u * (zz3 rotated 90) --\n"
"           zz2 - u/3 * zz3 --\n"
"\t   zz1 + u/3 * zz3 + .25u * (zz3 rotated -90) -- cycle;\n"
"  endfor;\n"
"enddef;\n"
"\n"
"\n"
"def l_rope_SKBB (expr P, show_anchors, show_rebelays) =\n"
"  T:=identity;\n"
"  pickup PenC;\n"
"  if not show_rebelays:\n"
"    draw P;\n"
"  else:\n"
"    d:=0.5u;\n"
"    for i:=0 upto (length P - 2):\n"
"      x1 := xpart point i of P;\n"
"      y1 := ypart point i of P;\n"
"      x2 := xpart point i+1 of P;\n"
"      y2 := ypart point i+1 of P;\n"
"    \n"
"      dx1:=x1; dy1:=y1; x1:=0; y1:=0; x2:=x2-dx1; y2:=y2-dy1;\n"
"      if y2 > y1:\n"
"        y3 := y1 - d;\n"
"        x3 := x1 + (x2-x1)*sqrt(d)/(sqrt(d)+sqrt(y2-y1+d));\n"
"      else:\n"
"        y3 := y2 - d;\n"
"        x3 := x1 + (x2-x1)*sqrt(y1-y2+d)/(sqrt(d)+sqrt(y1-y2+d));\n"
"      fi;\n"
"      numeric a,b,c;\n"
"      a*x1/10*x1 + b/10*x1 + c/10 = y1/10;\n"
"      a*x2/10*x2 + b/10*x2 + c/10 = y2/10;\n"
"      a*x3/10*x3 + b/10*x3 + c/10 = y3/10;\n"
"      draw (x1+dx1,y1+dy1)\n"
"      for t = x1 step (x2-x1)/20 until x2+10*epsilon:\n"
"        -- (t+dx1,a*t*t+b*t+c+dy1)\n"
"      endfor;\n"
"    endfor;\n"
"    pair x;\n"
"    x = point (length P)-1 of P + whatever * down;\n"
"    x = point (length P) of P + whatever * right;\n"
"    draw point (length P)-1 of P -- x;\n"
"  fi;\n"
"  if show_anchors:\n"
"    for i:=0 upto length P if show_rebelays: -1 fi:\n"
"      thdraw point i of P withpen pencircle scaled 0.25u;\n"
"    endfor;\n"
"  fi;\n"
"enddef;\n"
"\n"
"def l_border_presumed_SKBB (expr Path) =\n"
"  T:=identity;\n"
"  pickup PenC;\n"
"  draw Path dashed evenly scaled (0.25 * optical_zoom);\n"
"enddef;\n"
"\n"
"def l_steps_SKBB (expr P) =\n"
" if known ATTR_c: c := scantokens ATTR_c; else: c := 2; fi;\n"
" if ATTR__elevation:\n"
"   if (c < 2):\n"
"     thwarning(\"Invalid stairs definition (c<2)\");\n"
"     pickup PenA;\n"
"     draw P withcolor red;\n"
"   else:\n"
"     path PP;\n"
"     if (ypart point 0 of P) < (ypart point length P of P):\n"
"       PP := P;\n"
"     else:\n"
"       PP := reverse P;\n"
"     fi;\n"
"     path p;     \n"
"     for j:=0 upto ((length PP) - 1):\n"
"       p := (point j of PP) -- (point (j + 1) of PP);\n"
"       c := ceiling(abs((ypart point 0 of p) - (ypart point length p of p)) / (0.2 / Scale * 72 / 2.54));  % 20 cm height\n"
"       if (c < 2): c:=2 fi;\n"
"       pair cp;\n"
"       cp = point length p of p - point 0 of p;\n"
"       dx := (xpart cp) / c;\n"
"       dy := (ypart cp) / c;\n"
"       cp := point 0 of p;\n"
"       for i:= 0 upto c - 1:\n"
"         l_border_visible(cp -- cp + (0,dy) -- cp + (dx,dy));\n"
"         cp := cp + (dx, dy);\n"
"       endfor;\n"
"       %draw P;\n"
"     endfor;\n"
"   fi;\n"
" else:\n"
"   if known ATTR_l: l := scantokens ATTR_l; else: l := (length(P)-2)/2; fi;\n"
"   if ((length(P) < 4) or (c < 2)) or ((odd length P) and (not known ATTR_l)):\n"
"     thwarning(\"Invalid stairs definition\" if c<2: &\" (c<2)\" fi);\n"
"     pickup PenA;\n"
"     draw P withcolor red;\n"
"   else:\n"
"     path p, q;\n"
"     p = subpath (1, 1+l) of P;\n"
"     q = reverse subpath (l+2, length(P)) of P;\n"
"     lp := arclength(p);\n"
"     lq := arclength(q);\n"
"     for i=1 upto c:\n"
"       l_border_visible(point(arctime ((i-1)/(c-1)*lp) of p) of p -- point(arctime ((i-1)/(c-1)*lq) of q) of q);\n"
"     endfor;\n"
"     l_border_visible(p);\n"
"     l_border_visible(q);\n"
"     drawoptions(withcolor 0.3*white);\n"
"     %p_label(decimal c, point 0.5 of P, 0, 6);\n"
"     drawoptions();\n"
"   fi;\n"
" fi;\n"
"enddef;\n"
"\n"
"def l_handrail_SKBB (expr P) = \n"
"    if ATTR__elevation:\n"
"      T:=identity;\n"
"      cas := 0;\n"
"      dlzka := arclength P;\n"
"      mojkrok:=adjust_step(dlzka, 1u);\n"
"      pickup PenD;  \n"
"      pair tmppoint;\n"
"      tmph := 1 / Scale * 72 / 2.54;  % 1 m height\n"
"      tmppoint:=(point 0 of P) +(0,tmph);\n"
"      forever:\n"
"        t := arctime cas of P;\n"
"        draw point t of P -- (point t of P)+(0,tmph) withpen PenD;\n"
"        if cas > 0:\n"
"          draw tmppoint -- (point t of P)+(0,tmph) withpen PenC;\n"
"          tmppoint := (point t of P)+(0,tmph);\n"
"        fi;\n"
"        cas := cas + mojkrok;\n"
"        exitif cas > dlzka + (mojkrok / 3); % for rounding errors\n"
"      endfor;\n"
"    else:\n"
"      T:=identity;\n"
"      cas := 0;\n"
"      pair coord;\n"
"      sq_size:=0.12u;\n"
"      dlzka := arclength P;\n"
"      mojkrok:=adjust_step(dlzka, u);\n"
"      pickup PenD;  \n"
"      forever:\n"
"        t := arctime cas of P;\n"
"        coord := point t of P;\n"
"        thfill coord+(-sq_size,-sq_size)--coord+(sq_size,-sq_size)--coord+(sq_size,sq_size)--coord+(-sq_size,sq_size)--cycle;\n"
"        cas := cas + mojkrok;\n"
"        exitif cas > dlzka + (mojkrok / 3); % for rounding errors\n"
"      endfor;\n"
"      pickup PenC;  \n"
"      thdraw P;\n"
"    fi;\n"
"enddef;\n"
"\n"
"def l_fixedladder_SKBB (expr P) = \n"
"  pickup PenD;\n"
"  draw P withcolor red;\n"
"enddef;\n"
"\n"
"def l_ropeladder_SKBB (expr P) = \n"
"  pickup PenD;\n"
"  draw P withcolor red;\n"
"enddef;\n"
"\n"
"def l_viaferrata_SKBB (expr P) = \n"
"  pickup PenD;\n"
"  draw P withcolor red;\n"
"enddef;\n"
"\n"
"\n\n\n%%%%% ENDINPUT thLine %%%%%\n\n\n"
"\n\n\n%%%%% INPUT thArea %%%%%\n\n\n"
"%% therion source code\n"
"%%\n"
"%% This file defines tiling patterns\n"
"%%\n"
"%% $Date: 2003/07/01 09:06:44 $\n"
"%% $RCSfile: thPatterns.mp,v $\n"
"%% $Revision: 1.6 $\n"
"%%\n"
"%% Copyright (C) 2000-2004 Martin Budaj\n"
"%%\n"
"%% -------------------------------------------------------------------- \n"
"%% This program is free software; you can redistribute it and/or modify\n"
"%% it under the terms of the GNU General Public License as published by\n"
"%% the Free Software Foundation; either version 2 of the License, or\n"
"%% any later version.\n"
"%%\n"
"%% This program is distributed in the hope that it will be useful,\n"
"%% but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
"%% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n"
"%% GNU General Public License for more details.\n"
"%% \n"
"%% You should have received a copy of the GNU General Public License\n"
"%% along with this program; if not, write to the Free Software\n"
"%% Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n"
"%% --------------------------------------------------------------------\n"
"\n"
"if unknown a_water_UIS: else: endinput fi;\n"
"\n"
"% patterns\n"
"\n"
"beginpattern(pattern_water_UIS);\n"
"    draw origin--10up withpen pensquare scaled (0.02u);\n"
"    patternxstep(.18u);\n"
"    patterntransform(identity rotated 45);\n"
"endpattern;\n"
"\n"
"beginpattern(pattern_sump_UIS);\n"
"    draw origin--(0,.25u) withpen pensquare scaled (0.02u);\n"
"    draw origin--(.25u,0) withpen pensquare scaled (0.02u);\n"
"    patterntransform(identity rotated 45);\n"
"endpattern;\n"
"\n"
"beginpattern(pattern_sand_UIS);\n"
"    pickup PenC;\n"
"    draw (0.2u,.3u);\n"
"    draw (0.35u,.7u);\n"
"    draw (0.6u,.5u);\n"
"    draw (0.8u,.1u);    \n"
"endpattern;\n"
"\n"
"beginpattern(pattern_debris_SKBB);\n"
"    pickup PenC;\n"
"    p:=(-.15u,0)--(.15u,0);\n"
"    draw p rotated -40 shifted (.2u,.3u);\n"
"    draw p rotated 70 shifted (.9u,1.5u);\n"
"    draw p rotated 20 shifted (1.5u,.8u);\n"
"%    draw p rotated 95 shifted (.9u,.8u);\n"
"endpattern;\n"
"\n"
"\n"
"beginpattern(pattern_moonmilk_SKBB);\n"
"    pickup PenC;\n"
"    p:=(-.5u,0){down} .. {up}(-.1666u,0){down}..\n"
"        {up}(.1666u,0){down} .. {up}(.5u,0);\n"
"    draw p;\n"
"    draw p shifted (0.5u,0.3u);\n"
"    patternxstep(1.0u);\n"
"    patternystep(0.6u);\n"
"endpattern;\n"
"\n"
"\n"
"beginpattern(pattern_flowstone_ASF);\n"
"    pickup PenC;\n"
"    p:=(-.35u,0){dir -60} .. {dir 60}(0.35u,0);\n"
"    draw p;\n"
"    draw p shifted (0.35u,0.4u);\n"
"    patternxstep(u);\n"
"    patternystep(0.8u);\n"
"endpattern;\n"
"\n"
"\n"
"beginpattern(pattern_empty);\n"
"  patternbbox(0,0,10,10);\n"
"  patternstep(10,10);\n"
"endpattern;\n"
"\n"
"% symbols\n"
"\n"
"def a_water_UIS (expr Path) =\n"
"  T:=identity;\n"
"  thclean Path;\n"
"  thfill Path withpattern pattern_water_UIS;\n"
"enddef;\n"
"\n"
"def a_sump_UIS (expr Path) =\n"
"  T:=identity;\n"
"  thclean Path;\n"
"  thfill Path withpattern pattern_sump_UIS;\n"
"enddef;\n"
"\n"
"\n"
"def a_flowstone_ASF (expr Path) =\n"
"  T:=identity;\n"
"  thclean Path;\n"
"  thfill Path withpattern pattern_flowstone_ASF;\n"
"enddef;\n"
"\n"
"\n"
"def a_moonmilk_SKBB (expr Path) =\n"
"  T:=identity;\n"
"  thclean Path;\n"
"  thfill Path withpattern pattern_moonmilk_SKBB;\n"
"enddef;\n"
"\n"
"\n"
"\n"
"def a_sand_UIS (expr p) =\n"
"  T:=identity;\n"
"%  thclean p;\n"
"  pickup PenC;\n"
"  path q; q = bbox p;\n"
"  picture tmp_pic; \n"
"  tmp_pic := image(\n"
"    for i = xpart llcorner q step 1u until xpart urcorner q:\n"
"      for j = ypart llcorner q step 1u until ypart urcorner q:\n"
"        draw origin shifted ((i,j) randomized 0.7u) withpen PenC;\n"
"      endfor;  \n"
"    endfor;\n"
"  );\n"
"  clip tmp_pic to p;\n"
"  drawoptions();\n"
"  draw tmp_pic;\n"
"enddef;\n"
"\n"
"def a_debris_UIS (expr Path) =\n"
"  T:=identity;\n"
"%  thclean Path;\n"
"  thfill Path withpattern pattern_debris_SKBB;\n"
"enddef;\n"
"\n"
"\n"
"def a_bedrock_SKBB (expr Path) =\n"
"  T:=identity;\n"
"  thclean Path;\n"
"enddef;\n"
"\n"
"\n"
"% used to export centerline LRUD envelope for maps created from surveys\n"
"\n"
"def a_dimensions_SKBB (expr Path) =\n"
"  T:=identity;\n"
"  thclean Path;\n"
"enddef;\n"
"\n"
"\n"
"def a_debris_SKBB (expr p) =\n"
"  T:=identity;\n"
"%  thclean p;\n"
"  pickup PenC;\n"
"  path q; q = bbox p;\n"
"  picture tmp_pic; \n"
"  tmp_pic := image(\n"
"    for i = xpart llcorner q step 1u until xpart urcorner q:\n"
"      for j = ypart llcorner q step 1u until ypart urcorner q:\n"
"        draw ((-.2u,0)--(.2u,0)) \n"
"             rotated uniformdeviate(360) \n"
"             shifted ((i,j) randomized 0.6u) withpen PenC;\n"
"      endfor;  \n"
"    endfor;\n"
"  );\n"
"  clip tmp_pic to p;\n"
"  drawoptions();\n"
"  draw tmp_pic;\n"
"enddef;\n"
"\n"
"def a_clay_SKBB (expr p) =\n"
"  T:=identity;\n"
"  pickup PenC;\n"
"  path q, qq; q = bbox p;\n"
"  picture tmp_pic; \n"
"  tmp_pic := image(\n"
"    for i = xpart llcorner q step 1.5u until xpart urcorner q:\n"
"      for j = ypart llcorner q step 1.5u until ypart urcorner q:\n"
"        qq := ((-.25u,0){up}..origin{down}..{up}(0.25u,0)) randomized (u/15)\n"
"             shifted ((i,j) randomized 1.3u);\n"
"\tif xpart (p intersectiontimes qq) < 0:\n"
"\t  thdraw qq;\n"
"\tfi;\n"
"      endfor;  \n"
"    endfor;\n"
"  );\n"
"  clip tmp_pic to p;\n"
"  drawoptions();\n"
"  draw tmp_pic;\n"
"enddef;\n"
"\n"
"def a_ice_SKBB (expr p) =\n"
"  T:=identity;\n"
"  pickup PenC;\n"
"  path q; q = bbox p;\n"
"  picture tmp_pic, tmp_ice; \n"
"  pair z;\n"
"  tmp_ice := image (\n"
"    draw (-.2u,0)--(.2u,0);\n"
"    draw (0,-.2u)--(0,.2u);\n"
"  );\n"
"  tmp_pic := image(\n"
"    for i = xpart llcorner q step 1.5u until xpart urcorner q:\n"
"      for j = ypart llcorner q step 1.5u until ypart urcorner q:\n"
"        z := ((i,j) randomized 1.3u);\n"
"\tif xpart (p intersectiontimes ((bbox tmp_ice) shifted z)) < 0:\n"
"\t  draw tmp_ice shifted z;\n"
"\tfi;\n"
"      endfor;  \n"
"    endfor;\n"
"  );\n"
"  clip tmp_pic to p;\n"
"  drawoptions();\n"
"  draw tmp_pic;\n"
"enddef;\n"
"\n"
"\n"
"def a_snow_SKBB (expr P) =\n"
"  T:=identity;\n"
"  pickup PenC;\n"
"  path q; q = bbox P;\n"
"  picture tmp_pic, tmp_sn; \n"
"  pair z;\n"
"  tmp_sn := image(\n"
"    pickup PenC;\n"
"    p := origin--(0,.2*u);\n"
"    draw p; draw p rotated (60); draw p rotated (120);\n"
"    draw p rotated (180); draw p rotated (240); draw p rotated (300);\n"
"    p := ((0,.3u)--(0,0.2u)--(0.1u,0.2u)) rotatedaround ((0,0.2u),45);\n"
"    draw p; draw p rotated (60); draw p rotated (120);\n"
"    draw p rotated (180); draw p rotated (240);\n"
"    draw p rotated (300);\n"
"  );\n"
"  tmp_pic := image(\n"
"    for i = xpart llcorner q step 1.5u until xpart urcorner q:\n"
"      for j = ypart llcorner q step 1.5u until ypart urcorner q:\n"
"        z:=((i,j) randomized 1.3u);\n"
"\tif xpart (P intersectiontimes ((bbox tmp_sn) shifted z)) < 0:\n"
"          draw tmp_sn shifted z;\n"
"\tfi;\n"
"      endfor;  \n"
"    endfor;\n"
"  );\n"
"  clip tmp_pic to P;\n"
"  drawoptions();\n"
"  draw tmp_pic;\n"
"enddef;\n"
"\n"
"def a_blocks_SKBB (expr p) =\n"
"  T:=identity;\n"
"  pickup PenC;\n"
"  path q, qq; q = bbox p;\n"
"  picture tmp_pic; \n"
"  uu := max(u, (xpart urcorner q - xpart llcorner q)/100, (ypart urcorner q - ypart llcorner q)/100);\n"
"  tmp_pic := image(\n"
"    for i = xpart llcorner q step 2uu until xpart urcorner q:\n"
"      for j = ypart llcorner q step 2uu until ypart urcorner q:\n"
"        qq := punked (((-.5uu,-.5uu)--(.5uu,-.5uu)--(.5uu,.5uu)--(-.5uu,.5uu)--cycle) \n"
"\t     randomized (uu/2))\n"
"             rotated uniformdeviate(360) \n"
"             shifted ((i,j) randomized 1.6uu);\n"
"\tif xpart (p intersectiontimes qq) < 0:\n"
"\t  thclean qq;\n"
"\t  thdraw qq;\n"
"\tfi;\n"
"      endfor;  \n"
"    endfor;\n"
"  );\n"
"  clip tmp_pic to p;\n"
"  drawoptions();\n"
"  draw tmp_pic;\n"
"enddef;\n"
"\n"
"def a_blocks_SKBB_ (expr p,o,s_beg,s_end,d_beg,d_end) =\n"
"  T:=identity;\n"
"  orient = 90-o;\n"
"  pickup PenC;\n"
"  path q[], qq; q1 = bbox p;\n"
"  draw q1; draw p;\n"
"  q2 = llcorner q1 .. lrcorner q1 .. urcorner q1 .. ulcorner q1 .. cycle;\n"
"  draw q2;\n"
"  pair zz[];\n"
"  radius := .5*length(llcorner q1 - urcorner q1);\n"
"  zz1 := .5[llcorner q1,urcorner q1];\n"
"  zz2 := zz1 - dir(orient)*radius;\n"
"  zz3 = zz1 rotatedaround (zz2,90);\n"
"  draw zz1 withpen pencircle scaled 2mm;\n"
"  draw zz2 withpen pencircle scaled 2mm;\n"
"  draw zz3 withpen pencircle scaled 2mm;\n"
"  picture tmp_pic; \n"
"  tmp_pic := image(\n"
"    j := 0;\n"
"    forever:\n"
"      i := 0;\n"
"      forever:\n"
"        qq := punked (((-.5,-.5)--(.5,-.5)--(.5,.5)--(-.5,.5)--cycle) \n"
"             scaled (0.7(5u-(j/(2*radius))[u*s_beg,u*s_end]))\n"
"\t     randomized (u/2))\n"
"             rotated uniformdeviate(360) \n"
"             shifted (((zz3 + (i,j)) rotatedaround (zz3,-o)) randomized 1.6u);\n"
"        draw ((zz3 + (i,j)) rotatedaround (zz3,-o)) withpen pencircle scaled 1mm withcolor red;\n"
"\tif xpart (p intersectiontimes qq) < 0:\n"
"\t  thclean qq;\n"
"\t  thdraw qq;\n"
"\tfi;\n"
"        i := i + (j/(2*radius))[u*d_beg,u*d_end];\n"
"        exitif i > 2*radius;\n"
"      endfor;  \n"
"      j := j + (j/(2*radius))[u*d_beg,u*d_end];\n"
"      exitif j > 2*radius;\n"
"    endfor;\n"
"  );\n"
"%  clip tmp_pic to p;\n"
"  drawoptions();\n"
"  draw tmp_pic;\n"
"enddef;\n"
"\n"
"\n"
"def a_pebbles_SKBB (expr p) =\n"
"  T:=identity;\n"
"  pickup PenC;\n"
"  path q, qq; q = bbox p;\n"
"  picture tmp_pic; \n"
"  tmp_pic := image(\n"
"    for i = xpart llcorner q step 1.5u until xpart urcorner q:\n"
"      for j = ypart llcorner q step 1.5u until ypart urcorner q:\n"
"        qq := (superellipse((.2u,0),(0,.1u),(-.2u,0),(0,.-.1u),.75))\n"
"%             randomized (u/25)\n"
"             rotated uniformdeviate(360) \n"
"             shifted ((i,j) randomized 0.8u);\n"
"\tif xpart (p intersectiontimes qq) < 0:\n"
"\t  thdraw qq;\n"
"\tfi;\n"
"      endfor;  \n"
"    endfor;\n"
"  );\n"
"  clip tmp_pic to p;\n"
"  drawoptions();\n"
"  draw tmp_pic;\n"
"enddef;\n"
"\n"
"def a_water_SKBB (expr Path) =\n"
"  T:=identity;\n"
"  thfill Path;\n"
"enddef;\n"
"\n"
"let a_sump_SKBB = a_water_SKBB;\n"
"\n"
"def a_u (expr p) =\n"
"    T:=identity;\n"
"    thfill p withcolor red;\n"
"enddef;\n"
"\n"
"\n\n\n%%%%% ENDINPUT thArea %%%%%\n\n\n"
"\n\n\n%%%%% INPUT thText %%%%%\n\n\n"
"%% therion source code\n"
"%%\n"
"%% This file defines macros for labels\n"
"%%\n"
"%% $Date: 2003/07/01 09:06:44 $\n"
"%% $RCSfile: thText.mp,v $\n"
"%% $Revision: 1.6 $\n"
"%%\n"
"%% Copyright (C) 2000-2004 Martin Budaj\n"
"%%\n"
"%% -------------------------------------------------------------------- \n"
"%% This program is free software; you can redistribute it and/or modify\n"
"%% it under the terms of the GNU General Public License as published by\n"
"%% the Free Software Foundation; either version 2 of the License, or\n"
"%% any later version.\n"
"%%\n"
"%% This program is distributed in the hope that it will be useful,\n"
"%% but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
"%% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n"
"%% GNU General Public License for more details.\n"
"%% \n"
"%% You should have received a copy of the GNU General Public License\n"
"%% along with this program; if not, write to the Free Software\n"
"%% Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n"
"%% --------------------------------------------------------------------\n"
"\n"
"labeloffset:=0bp;\n"
"\n"
"def l_label(expr txt,path) =\n"
"  picture pict,pic;\n"
"  pair pos;\n"
"  numeric dx[],dy[],ptime;\n"
"  string ss,ch;\n"
"\n"
"  pic := thelabel(txt,(0,0));\n"
"  strl := xpart(lrcorner pic - llcorner pic);\n"
"  pathl := arclength (path);\n"
"  dx0 := xpart(llcorner pic);\n"
"%  dy0 := ypart(llcorner pic);\n"
"\n"
"  if strl>pathl:\n"
"    txtzoom := pathl / strl;\n"
"    thwarning(\"text scaled down to fit the path\");\n"
"  else:\n"
"    txtzoom := 1;\n"
"  fi;\n"
"  zoom := pathl / strl;\n"
"\n"
"  for p within pic:\n"
"    if textual p:                                \n"
"      ss := textpart p;\n"
"      dx1 := xpart p;\n"
"      dy1 := ypart p;\n"
"      dx2 := dx1;\n"
"\n"
"      if xxpart p / yypart p <> 1: message(\"Error: distorted text!\") fi;\n"
"      txtscale := txtzoom * xxpart p;\n"
"\n"
"      l := length(ss);\n"
"      ptime := 0;\n"
"      for i=0 upto (l - 1):\n"
"        ch := substring(i,i+1) of ss;\n"
"        pict := ch infont fontpart p scaled txtscale;\n"
"        charwidth := xpart (lrcorner pict - llcorner pict) / txtzoom;\n"
"        dy2 := ypart lrcorner pict / txtzoom;\n"
"        ptime := (dx2 - dx0 + 0.5*charwidth) * zoom;\n"
"        t := arctime ptime of (path);\n"
"        pos := point t of path + \n"
"          (dy1+dy2)*txtzoom*unitvector((direction t of path) rotated 90);\n"
"        begingroup\n"
"%          interim labeloffset:=0bp;\n"
"          lab:=thelabel.top(pict,pos);\n"
"          process_label(pos,angle direction t of path);\n"
"        endgroup;\n"
"        dx2 := dx2 + charwidth;\n"
"      endfor;\n"
"\n"
"    else: message(\"Strange component of line label!\");\n"
"    fi;\n"
"  endfor;\n"
"  % draw path;\n"
"enddef;\n"
"\n"
"vardef p_label@#(expr txt,pos,rot,mode) =\n"
"  if (mode=1) or (mode=7): interim labeloffset:=(u/8) fi;\n"
"  lab:=thelabel@#(txt, pos);\n"
"  if mode>1: pickup PenD fi;\n"
"  if mode=1:\n"
"    pickup pencircle scaled (u/6);\n"
"    drawdot(pos);\n"
"    process_label(pos,0);\n"
"  elseif mode=2: process_uplabel;       \n"
"  elseif mode=3: process_downlabel;\n"
"  elseif mode=4: process_updownlabel;\n"
"  elseif mode=5: process_circledlabel;\n"
"  elseif mode=6: process_boxedlabel;\n"
"  elseif mode=7: process_label(pos,rot);  % station name\n"
"  elseif mode=8: process_filledlabel(pos, rot);\n"
"  else: process_label(pos,rot); fi;\n"
"enddef;\n"
"\n"
"\n"
"% at beginfig: save smartll[], smartur[]; pair smartll[], smartur[]; smart_count=0;\n"
"numeric smart_count, smart_D;\n"
"boolean smart_quit, smart_inner_quit;\n"
"\n"
"def p_smartlabel (expr txt, pos) =\n"
"  begingroup;\n"
"  interim bboxmargin:=0.2pt;\n"
"  lab:=thelabel.rt(txt,pos+(0.4u,0));\n"
"  q:=bbox lab;\n"
"  smart_D := 0;\n"
"  forever:\n"
"    smart_quit := true;\n"
"    smart_inner_quit := false;\n"
"    for i=1 upto smart_count:\n"
"      if smart_overlap(((point 0 of q) shifted (0,smart_D)), \n"
"                       ((point 2 of q) shifted (0,smart_D)),\n"
"                       smartll[i], smartur[i]) = 1:\n"
"        smart_quit := false;\n"
"        smart_D := smart_D - 3pt;\n"
"        smart_inner_quit := true;\n"
"      fi;\n"
"      exitif smart_inner_quit;\n"
"    endfor;\n"
"    exitif smart_quit;\n"
"  endfor;\n"
"  smart_U := 0;\n"
"  forever:\n"
"    smart_quit := true;\n"
"    smart_inner_quit := false;\n"
"    for i=1 upto smart_count:\n"
"      if smart_overlap(((point 0 of q) shifted (0,smart_U)), \n"
"                       ((point 2 of q) shifted (0,smart_U)),\n"
"                       smartll[i], smartur[i]) = 1:\n"
"        smart_quit := false;\n"
"        smart_U := smart_U + 3pt;\n"
"        smart_inner_quit := true;\n"
"      fi;\n"
"      exitif smart_inner_quit;\n"
"    endfor;\n"
"    exitif smart_quit;\n"
"  endfor;\n"
"  if (smart_U < -smart_D): smart_D := smart_U; fi;\n"
"  draw lab shifted (0,smart_D);\n"
"  if (abs(smart_D)>3pt):\n"
"    pickup PenB;\n"
"    draw pos{left}..{right}(pos shifted (.4u, smart_D)) dashed withdots scaled 0.2;\n"
"    pickup PenA;\n"
"    drawdot pos;\n"
"  fi;\n"
"  smart_count := smart_count + 1;\n"
"  smartll[smart_count] := point 0 of (q shifted (0,smart_D));\n"
"  smartur[smart_count] := point 2 of (q shifted (0,smart_D));\n"
"  endgroup;\n"
"enddef;\n"
"\n"
"def smart_overlap (expr llA, urA, llB, urB) =\n"
"  if ((xpart llA < xpart urB) and (xpart urA > xpart llB)) and\n"
"     ((ypart llA < ypart urB) and (ypart urA > ypart llB)):\n"
"    1\n"
"  else:\n"
"    0 \n"
"  fi\n"
"enddef;\n"
"\n"
"\n"
"\n"
"\n"
"def p_wallaltitude (expr pprev,pos,pnext,txt) =\n"
"  rot:=angle(unitvector(pnext-pos)+unitvector(pos-pprev)) - 90;\n"
"  pickup PenD;\n"
"  pair zz;\n"
"%  zz:=(pos + 3*unitvector(dir rot));\n"
"  zz:=(pos + (u/4)*unitvector(dir rot));\n"
"  draw (pos)--zz;\n"
"  begingroup \n"
"%    interim labeloffset:=2pt;\n"
"    interim labeloffset:=(u/12);\n"
"    if horiz_labels:\n"
"      rot:=rot mod 360;\n"
"      if rot<=22.5: lab:=thelabel.rt(txt, zz);\n"
"      elseif rot<=67.5: lab:=thelabel.urt(txt, zz);\n"
"      elseif rot<=112.5: lab:=thelabel.top(txt, zz);\n"
"      elseif rot<=157.5: lab:=thelabel.ulft(txt, zz);\n"
"      elseif rot<=202.5: lab:=thelabel.lft(txt, zz);\n"
"      elseif rot<=247.5: lab:=thelabel.llft(txt, zz);\n"
"      elseif rot<=292.5: lab:=thelabel.bot(txt, zz);\n"
"      elseif rot<=337.5: lab:=thelabel.lrt(txt, zz);\n"
"      else: lab:=thelabel.rt(txt, zz);\n"
"      fi;\n"
"    else:\n"
"      if (abs rot>90) and (abs rot <=270):\n"
"        rot:=rot-180;\n"
"        lab:=thelabel.lft(txt, pos);\n"
"      else:\n"
"        lab:=thelabel.rt(txt, pos);\n"
"      fi;\n"
"    fi;\n"
"    process_label(pos, if horiz_labels: 0 else: rot fi);\n"
"  endgroup;\n"
"enddef;\n"
"\n"
"\n\n\n%%%%% ENDINPUT thText %%%%%\n\n\n"
"\n\n\n%%%%% INPUT thSpecial %%%%%\n\n\n"
"%% therion source code\n"
"%%\n"
"%% This file defines macros for special symbols\n"
"%%\n"
"%% $Date: $\n"
"%% $RCSfile: $\n"
"%% $Revision: $\n"
"%%\n"
"%% Copyright (C) 2004 Martin Budaj\n"
"%%\n"
"%% -------------------------------------------------------------------- \n"
"%% This program is free software; you can redistribute it and/or modify\n"
"%% it under the terms of the GNU General Public License as published by\n"
"%% the Free Software Foundation; either version 2 of the License, or\n"
"%% any later version.\n"
"%%\n"
"%% This program is distributed in the hope that it will be useful,\n"
"%% but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
"%% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n"
"%% GNU General Public License for more details.\n"
"%% \n"
"%% You should have received a copy of the GNU General Public License\n"
"%% along with this program; if not, write to the Free Software\n"
"%% Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n"
"%% --------------------------------------------------------------------\n"
"\n"
"def s_northarrow_SKBB_old (expr rot) = \n"
"  T:=identity;\n"
"  picture tmp_pic;\n"
"  tmp_pic = image (\n"
"    begingroup\n"
"      interim defaultscale:=3;\n"
"      label(if (lang=\"sk\") or (lang=\"cz\"): \"S\" else: \"N\" fi, origin);\n"
"    endgroup;\n"
"    drawarrow (0,-1cm)--(0,1cm);\n"
"  );\n"
"  draw tmp_pic rotatedaround(origin, -rot);\n"
"enddef;\n"
"\n"
"def s_northarrow_SKBB (expr rot) =\n"
"  T:=identity scaled 0.7 rotated -rot;\n"
"  thdraw (-.5cm,-1cm)--(0,1.5cm)--(.5cm,-1cm)--(0,-.5cm)--cycle;\n"
"  thfill (-.5cm,-1cm)--(0,1.5cm)--(0,-.5cm)--cycle;\n"
"enddef;\n"
"\n"
"def s_scalebar_SKBB (expr l, units, txt) = \n"
"  begingroup\n"
"    interim warningcheck:=0;\n"
"    tmpl:=l / Scale * cm * units / 2;\n"
"  endgroup;\n"
"  pickup PenC;\n"
"  draw (-tmpl,0)--(tmpl,0);\n"
"  draw (-tmpl,0)--(-tmpl,2bp);\n"
"  draw (tmpl,0)--(tmpl,2bp);\n"
"  begingroup\n"
"    interim labeloffset:=2bp;\n"
"    label.top(thTEX(decimal (l) & \"\\thinspace\" & txt),origin);\n"
"  endgroup\n"
"enddef;\n"
"\n"
"def s_scalebar_SM (expr l, units, txt) = \n"
"  begingroup\n"
"    interim warningcheck:=0;\n"
"    tmpl:=l / Scale * cm * units / 2;\n"
"  endgroup;\n"
"  pickup PenC;\n"
"  draw (-tmpl,0)--(tmpl,0);\n"
"  draw (-tmpl,0)--(-tmpl,2bp);\n"
"  draw (tmpl,0)--(tmpl,2bp);\n"
"  draw (0,0)--(0,2bp);\n"
"  begingroup\n"
"    interim labeloffset:=3.5bp;\n"
"    label.top(thTEX(decimal (0)),(-tmpl,0));\n"
"    label.top(thTEX(decimal (l/2)),origin);\n"
"    label.top(thTEX(decimal (l) & \"\\thinspace\" & txt),(tmpl,0));\n"
"  endgroup\n"
"enddef;\n"
"\n"
"\n"
"def s_hgrid_SM (expr xpos, ypos, xsize, ysize) =\n"
"  pickup PenD;\n"
"  draw (\n"
"    if xpos < 0: 0 else: -5mm fi, 0\n"
"  ) -- (\n"
"    if xpos > 0: 0 else: 5mm fi, 0\n"
"  );\n"
"  draw (\n"
"    0, if ypos < 0: 0 else: -5mm fi\n"
"  ) -- (\n"
"    0, if ypos > 0: 0 else: 5mm fi\n"
"  );\n"
"enddef;\n"
"\n"
"\n"
"def s_vgrid_SM (expr xpos, ypos, xsize, ysize) =\n"
"  pickup PenD;\n"
"  draw (\n"
"    if xpos < 0: 0 else: -xsize/2 fi, 0\n"
"  ) -- (\n"
"    if xpos > 0: 0 else: xsize/2 fi, 0\n"
"  ) dashed evenly;\n"
"enddef;\n"
"\n"
"\n\n\n%%%%% ENDINPUT thSpecial %%%%%\n\n\n"
"\n\n\n%%%%% INPUT uAUT %%%%%\n\n\n"
"% Austrian Symbol Set, author Georg Pacher\n"
"\n"
"% color (for Austrian symbol-set)\n"
"\n"
"color col_water_bg;\n"
"col_water_bg :=(226/255,244/255,253/255);\n"
"\n"
"%%%%%%%%%%%%%%%%%%%%%%%\n"
"\n"
"\n"
"%% areas\n"
"\n"
"% returns true if pair point lies within path q. \n"
"% outside_point is any pair outside of path q (needed for reference).\n"
"vardef pointinside(expr pt,q,outside_point)=\n"
"  T:=identity;\n"
"  path test;\n"
"  test:= outside_point--pt;\n"
"  %thdraw test;\n"
"  boolean isinside;\n"
"  isinside:=false;\n"
"  numintersections:=recgetnumintersections(test,q,0);\n"
"  if (numintersections <0):\n"
"    isinside:=true;\n"
"  elseif odd(numintersections):\n"
"     isinside:=true;\n"
"  else:\n"
"     isinside:=false;\n"
"  fi;\n"
"  isinside\n"
"enddef;\n"
"\n"
"% get number of intersection between paths p (length 1!) and q\n"
"% recnum is needed for limitation of recursions. \n"
"% If the number of allowed recursions is reached, a negativ number of intersections is returned\n"
"vardef recgetnumintersections(expr p,q,recnum)=\n"
"  \n"
"  pair inter;\n"
"  save preinter;\n"
"  save postinter;\n"
"  save numintersections;\n"
"  path preinter, postinter;\n"
"  inter:=p intersectiontimes q;\n"
"  %show recnum;\n"
"  if recnum >25:\n"
"    numintersections:=-100;\n"
"  else:  \n"
"    if xpart(inter)>0 :\n"
"     %show (xpart inter);\n"
"    % split p into two paths and call yourself again\n"
"    \n"
"    preinter:=subpath (0,xpart(inter)-2eps) of p;\n"
"    \n"
"    postinter:=subpath (xpart(inter)+2eps,1) of p;\n"
"    \n"
"    numintersections:= recgetnumintersections(preinter,q,recnum+1)\n"
"                     + recgetnumintersections(postinter,q,recnum+1)\n"
"                     + 1;\n"
"    else:\n"
"      numintersections:=0;\n"
"    fi;\n"
"  fi;\n"
"  numintersections\n"
"  \n"
"enddef;\n"
"\n"
"beginpattern(pattern_water_AUT);\n"
"    draw origin--10up withpen pensquare scaled (0.02u);\n"
"    patternxstep(.18u);\n"
"    patterntransform(identity rotated 90);\n"
"endpattern;\n"
"\n"
"beginpattern(pattern_sump_AUT);\n"
"    draw origin--(0,.25u) withpen pensquare scaled (0.02u);\n"
"    draw origin--(.25u,0) withpen pensquare scaled (0.02u);\n"
"endpattern;\n"
"\n"
"beginpattern(pattern_sand_AUT);\n"
"    pickup PenC;\n"
"    p:= origin -- (0.01u,0.01u);\n"
"    for i=0.0u step 0.2u until 2.4u:\n"
"        for j=0.0u step 0.2u until 2.4u:\n"
"          draw p rotated uniformdeviate(360) \n"
"           shifted ((i,j) randomized 0.09u);\n"
"        endfor;\n"
"    endfor;\n"
"    if BaseScale<=2.5:\n"
"      my_step:=2.4u;\n"
"    else:\n"
"      my_step:=2.6u;\n"
"    fi;\n"
"    patternstep(my_step,my_step);       \n"
"endpattern;\n"
"\n"
"beginpattern(pattern_pebbles_AUT);\n"
"    pickup PenC;\n"
"    path qq;\n"
"    for i=0.0u step 0.3u until 5.1u:\n"
"        for j=0.0u step 0.3u until 5.1u:\n"
"          qq := (superellipse((.1u,0),(0,.05u),(-.1u,0),(0,.-.05u),.75))\n"
"             randomized (u/45)\n"
"             scaled (uniformdeviate(0.4)+.55)\n"
"             rotated uniformdeviate(360) \n"
"             shifted ((i,j) randomized 0.15u);\n"
"           draw qq;\n"
"        endfor;\n"
"    endfor;\n"
"    patternstep(5.1u,5.1u);\n"
"endpattern;\n"
"\n"
"beginpattern(pattern_ice_AUT);\n"
"    pickup PenC;\n"
"    p:=(-.15u,.0u) -- (0.15u,.0u);\n"
"    draw p;\n"
"    draw p shifted (0.25u,.0u) rotated (90);\n"
"    draw p shifted (0.45u,0.25u);\n"
"    draw p shifted (0.0u,0.45u) rotated (90);\n"
"    patternxstep(.9u);\n"
"    patternystep(0.5u);\n"
"endpattern;\n"
"\n"
"def a_water_AUT (expr Path) =\n"
"  T:=identity;\n"
"  thclean Path;\n"
"  pickup PenC;\n"
"  thfill Path withcolor col_water_bg;\n"
"  thfill Path withpattern pattern_water_AUT;\n"
"  thdraw Path;\n"
"enddef;\n"
"\n"
"def a_sump_AUT (expr Path) =\n"
"  T:=identity;\n"
"  thclean Path;\n"
"  pickup PenC;\n"
"  thfill Path withcolor col_water_bg;\n"
"  thfill Path withpattern pattern_sump_AUT;\n"
"  thdraw Path;\n"
"enddef;\n"
"\n"
"def a_sand_AUT (expr Path) =\n"
"  T:=identity;\n"
"%  thclean Path;\n"
"  thfill Path withpattern pattern_sand_AUT ;\n"
"enddef;\n"
"\n"
"let a_clay_AUT = a_sand_AUT;\n"
"\n"
"\n"
"def a_pebbles_AUT (expr p) =\n"
"  T:=identity;\n"
"  thfill p withpattern pattern_pebbles_AUT;\n"
"enddef;\n"
"\n"
"\n"
"\n"
"def a_debris_AUT (expr p) =\n"
"  T:=identity;\n"
"  \n"
"  symbol_distance:=1.0;\n"
"  scale_factor:= 0.3;\n"
"  pickup PenC;\n"
"  path q, qq; q = bbox p;\n"
"  pair outside;\n"
"  outside:= ulcorner q + up;\n"
"  picture tmp_pic; \n"
"  uu := max(u, (xpart urcorner q - xpart llcorner q)/100, (ypart urcorner q - ypart     llcorner q)/100);\n"
"  tmp_pic := image(\n"
"     for i = xpart llcorner q step symbol_distance*uu until xpart urcorner q:\n"
"        for j = ypart llcorner q step symbol_distance*uu until ypart urcorner q:\n"
"           qq := punked (((-.5uu,-.5uu)--(.5uu,-.5uu)--(1.05uu,0.01uu)--(.5uu,.5uu)--(-.5uu,.5uu)--cycle) \n"
"           randomized (uu/2))\n"
"           scaled (uniformdeviate(0.4)+scale_factor )\n"
"           rotated uniformdeviate(360) \n"
"           shifted ((i,j) randomized 0.5uu);\n"
"           if xpart (p intersectiontimes qq) < 0:\n"
"             if pointinside((i,j),p,outside):\n"
"               thclean qq;\n"
"               thdraw qq;\n"
"             fi;\n"
"           else:\n"
"             qq:= qq scaled (uniformdeviate(.2)+.5 )\n"
"             if xpart (p intersectiontimes qq) < 0:\n"
"               if pointinside((i,j),p,outside):\n"
"                 thclean qq;\n"
"                 thdraw qq;\n"
"               fi;\n"
"             fi;\n"
"           fi;\n"
"        endfor;  \n"
"     endfor;\n"
"  );\n"
"  clip tmp_pic to p;\n"
"  drawoptions();\n"
"  draw tmp_pic;\n"
"enddef;  \n"
"\n"
"def a_ice_AUT (expr p) =\n"
"  T:=identity;\n"
"  thclean p;\n"
"  thfill p withpattern pattern_ice_AUT;\n"
"  pickup PenC;\n"
"  thdraw p;\n"
"enddef;\n"
"\n"
"def a_snow_AUT (expr P) =\n"
"  T:=identity;\n"
"  pickup PenC;\n"
"  path q; q = bbox P;\n"
"  picture tmp_pic, tmp_sn; \n"
"  pair z;\n"
"  tmp_sn := image(\n"
"    pickup PenC;\n"
"    p := origin--(0,.2*u);\n"
"    draw p; draw p rotated (60); draw p rotated (120);\n"
"    draw p rotated (180); draw p rotated (240); draw p rotated (300);\n"
"    p := ((0,.3u)--(0,0.2u)--(0.1u,0.2u)) rotatedaround ((0,0.2u),45);\n"
"    draw p; draw p rotated (60); draw p rotated (120);\n"
"    draw p rotated (180); draw p rotated (240);\n"
"    draw p rotated (300);\n"
"  );\n"
"  tmp_pic := image(\n"
"    for i = xpart llcorner q step 1.0u until xpart urcorner q:\n"
"      for j = ypart llcorner q step 1.0u until ypart urcorner q:\n"
"        z:=((i,j) randomized 0.5u);\n"
"\tif xpart (P intersectiontimes ((bbox tmp_sn) shifted z)) < 0:\n"
"          draw tmp_sn shifted z;\n"
"\tfi;\n"
"      endfor;  \n"
"    endfor;\n"
"  );\n"
"  clip tmp_pic to P;\n"
"  draw tmp_pic;\n"
"  thdraw P;\n"
"enddef;\n"
"\n"
"def a_blocks_AUT (expr p) =\n"
"   T:=identity;\n"
"  symbol_distance:=1.6;\n"
"  scale_factor:= 0.8;\n"
"  pickup PenC;\n"
"  path q, qq; q = bbox p;\n"
"  pair outside;\n"
"  outside:= ulcorner q + up;\n"
"  picture tmp_pic; \n"
"  uu := max(u, (xpart urcorner q - xpart llcorner q)/100, (ypart urcorner q - ypart     llcorner q)/100);\n"
"  tmp_pic := image(\n"
"     for i = xpart llcorner q step symbol_distance*uu until xpart urcorner q:\n"
"        for j = ypart llcorner q step symbol_distance*uu until ypart urcorner q:\n"
"           qq := punked (((-.5uu,-.5uu)--(.5uu,-.5uu)--(1.05uu,0.01uu)--(.5uu,.5uu)--(-.5uu,.5uu)--cycle) \n"
"           randomized (uu/2))\n"
"           scaled (uniformdeviate(0.7)+scale_factor )\n"
"           rotated uniformdeviate(360) \n"
"           shifted ((i,j) randomized 0.75uu);\n"
"           if xpart (p intersectiontimes qq) < 0:\n"
"             if pointinside((i,j),p,outside):\n"
"               thclean qq;\n"
"               thdraw qq;\n"
"             fi;\n"
"           else:\n"
"             qq:= qq scaled (uniformdeviate(.2)+.5 )\n"
"             if xpart (p intersectiontimes qq) < 0:\n"
"               if pointinside((i,j),p,outside):\n"
"                 thclean qq;\n"
"                 thdraw qq;\n"
"               fi;\n"
"             fi;\n"
"           fi;\n"
"        endfor;  \n"
"     endfor;\n"
"  );\n"
"  clip tmp_pic to p;\n"
"  drawoptions();\n"
"  draw tmp_pic;\n"
"enddef;  \n"
"\n"
"\n"
"%% lines\n"
"\n"
"def l_wall_pit_AUT (expr P) = \n"
"    T:=identity;\n"
"    % draw outer path\n"
"    pickup PenA;\n"
"    thdraw P;\n"
"\n"
"    laenge:= arclength P;\n"
"\n"
"    pair inner[],innerdir[], inter;\n"
"    pair test;\n"
"    \n"
"    samplingdistance:=max(0.15u,laenge/1500);\n"
" \n"
"    path testcircle;\n"
"    % testcircle, used to test, whether the path makes a 'v'-like bend, \n"
"    % where normal sampling and offsetting gives poor results for the parallel line\n"
"    % size of testcircle= size PenA/2 + 2* (distance between outer and inner line)\n"
"    % + PenC (inner line)\n"
"    testcircle := halfcircle scaled (.5*u/10+2*.125u+.5*u/10) shifted (0,.5*u/10);\n"
"    cur:=samplingdistance/2;\n"
"    count:=0;\n"
"    forever:\n"
"      t:= arctime cur of P;\n"
"      inter:=P intersectiontimes (testcircle rotated (angle thdir(P,t)) shifted (point t of P));\n"
"      \n"
"      %thdraw testcircle rotated (angle thdir(P,t)) shifted (point t of P) withpen (pencircle scaled 0.01u) ;\n"
"      if (xpart inter) >=0:\n"
"        % we are at a 'sharp bend', so set next point to intersectionpoint\n"
"        cur:=cur+samplingdistance;\n"
"        t := max( xpart inter, arctime cur of P);\n"
"        %thdraw point t of P withcolor 0.7*green;\n"
"        forever:\n"
"          t:= arctime cur of P;\n"
"          inter:=P intersectiontimes (testcircle rotated (angle thdir(P,t)) shifted (point t of P));\n"
"          exitif (xpart inter <0);\n"
"          cur := cur + samplingdistance;\n"
"          exitif (cur >=laenge); \n"
"        endfor;\n"
"        if (cur <laenge):\n"
"          inner[count]:=(point t of P + .125u*unitvector(thdir(P,t) rotated 90) );\n"
"          innerdir[count]:=unitvector(thdir(P,t));\n"
"          count := count+1;\n"
"        fi;\n"
"      else:\n"
"        inner[count]:= (point t of P + .125u*unitvector(thdir(P,t) rotated 90) );\n"
"        innerdir[count]:=unitvector(thdir(P,t));\n"
"        %thdraw inner[count] withpen PenD withcolor 0.5*red;\n"
"        count:=count +1;\n"
"        cur:= cur+ samplingdistance;\n"
"      fi;\n"
"      exitif (cur >=laenge);\n"
"    endfor;\n"
"    if count>2:\n"
"      % draw inner path\n"
"      pickup PenC;\n"
"      path innerpath;\n"
"      innerpath =\n"
"      for i=0 upto count-2:\n"
"        inner[i]{(innerdir[i])} ..\n"
"      endfor\n"
"      if cycle P: cycle;\n"
"      else:  inner[count-1];\n"
"      fi;\n"
"      thdraw innerpath;\n"
"        \n"
"    % draw the triangles\n"
"\n"
"    path draw_triangle;\n"
"    pair l_triangle;\n"
"       \n"
"    laenge:= arclength innerpath;\n"
"    symsize:= adjust_step(laenge,0.5u);\n"
"    triangle_width:=symsize/2;\n"
"    cur:=(symsize/2);\n"
"    t := arctime (cur) of innerpath;\n"
"    t1:= arctime (cur-triangle_width/2) of innerpath;\n"
"    t2:= arctime (cur+triangle_width/2) of innerpath;         \n"
"    l_triangle := (point t of innerpath);\n"
"    if ATTR__height >= 10: thfill else: thdraw fi (subpath (t1,t2) of innerpath) -- \n"
"           ((point t of innerpath) + symsize/2 * unitvector(thdir(innerpath,t) rotated 90))\n"
"           --  cycle;\n"
"\n"
"    for cur=(symsize/2) step symsize until laenge:\n"
"      t := arctime (cur) of innerpath;\n"
"      test := (point t of innerpath);\n"
"      my_dist := length(test-l_triangle);\n"
"      if (abs(my_dist-symsize) < 0.05u) or (my_dist>symsize):\n"
"         t1:= arctime (cur-triangle_width/2) of innerpath;\n"
"         t2:= arctime (cur+triangle_width/2) of innerpath;         \n"
"\t draw_triangle:=(subpath (t1,t2) of innerpath) -- \n"
"                        ((point t of innerpath) + symsize/2 * unitvector(thdir(innerpath,t) rotated 90))\n"
"                         --  cycle;\n"
"\t if xpart (draw_triangle intersectiontimes P) < 0:\n"
"\t    if ATTR__height >= 10: \n"
"\t      thfill draw_triangle;\n"
"\t    else:\n"
"\t      thclean draw_triangle;\n"
"\t      thdraw draw_triangle;\n"
"\t    fi;\n"
"\t    l_triangle:= test;\n"
"\t fi;\n"
"      fi;\n"
"    endfor;\n"
"    \n"
"    fi;\n"
"enddef;\n"
"\n"
"\n"
"def l_wall_sand_AUT (expr P) = \n"
"  T:=identity;\n"
"  cas := 0;\n"
"  dlzka := arclength P;\n"
"  mojkrok:=adjust_step(dlzka, 0.1u);\n"
"  pickup PenC;  \n"
"  forever:\n"
"    t := arctime cas of P;\n"
"    thdraw (((0.01u,0.01u)--origin) rotated uniformdeviate(360) shifted ((point t of P) + (uniformdeviate 1) * .4u \n"
"            * unitvector(thdir(P,t) rotated -90)));\n"
"    cas := cas + mojkrok;\n"
"    exitif cas > dlzka + (mojkrok / 3); % for rounding errors\n"
"  endfor;\n"
"  pickup PenC;  \n"
"  thdraw P;\n"
"\n"
"enddef;\n"
"\n"
"def l_wall_pebbles_AUT (expr P) = \n"
"  T:=identity;\n"
"  cas := 0;\n"
"  dlzka := arclength P;\n"
"  mojkrok:=adjust_step(dlzka, .18u);\n"
"  pickup PenC;\n"
"  q:=superellipse((.1u,0),(0,.05u),(-.1u,0),(0,.-.05u),.75);\n"
"  forever:\n"
"    t := arctime (cas + mojkrok/2) of P;\n"
"    thdraw q randomized (u/45) rotated (angle(thdir(P,t)) + (normaldeviate*40)) shifted point t of P;\n"
"    cas := cas + mojkrok;\n"
"    exitif cas > dlzka - (2*mojkrok/3); % for rounding errors\n"
"  endfor;\n"
"enddef;\n"
"\n"
"\n"
"let l_wall_clay_AUT = l_wall_sand_AUT;\n"
"\n"
"\n"
"def l_wall_debris_AUT (expr P) = \n"
"  T:=identity;\n"
"  pickup PenC;\n"
"  laenge := arclength P;\n"
"  path block;\n"
"  path old_block;\n"
"  \n"
"  cur := 0;\n"
"  t:= arctime cur of P;\n"
"  % draw first block\n"
"  old_block := (((-.0u,-.0u)--(.25u,-.15u)--(.45u,0.01u)--(.2u,.25u)--(.05u,.15u)--cycle));\n"
"  block_width := (xpart urcorner old_block - xpart ulcorner old_block);\n"
"  old_block:=old_block rotated angle(thdir(P,0)) shifted point t of P;\n"
"  thclean old_block;\n"
"  thdraw old_block;\n"
"   \n"
"  cur := cur + 0.9*block_width;\n"
"  t:= arctime cur of P;\n"
"\t% proceed with path\n"
"    forever:\n"
"\t  % generate random block\n"
"        block := punked (((-.25u,-.25u)--(0.25.u,-.25u)--(0.50u,0.01u)--(0.25u,.25u)--(-.25u,.25u)--cycle) \n"
"          randomized (u/4))\n"
"          scaled (uniformdeviate(0.3)+.4)\n"
"          rotated uniformdeviate(360);\n"
"\t  % check width of block\n"
"        block_width := (xpart urcorner block - xpart ulcorner block);\n"
"        exitif cur > (laenge- 2.5*block_width/2);\n"
"        % find next position where the block fits in without intersecting the previous one\n"
"\t  forever:           \n"
"\t    exitif xpart ( (block rotated angle(-direction t of P) shifted point t of P) intersectiontimes old_block) < 0;\n"
"            cur:=cur+0.01u;\n"
"            t:= arctime cur of P;\n"
"            exitif cur > (laenge- 2.5*block_width/2);\n"
"          endfor;\n"
"        exitif cur > (laenge- 2.5*block_width/2);\n"
"\n"
"        old_block:= block rotated angle(-direction t of P) shifted point t of P;\n"
"        thclean old_block;\n"
"        thdraw old_block;\n"
"        cur := cur + block_width/2;\n"
"        t:= arctime cur of P;\n"
"    endfor;\n"
"\tt:= arctime laenge-eps of P;\n"
"\n"
"\t% generate last block\n"
"      block := (((-.0u,-.0u)--(.25u,-.15u)--(.45u,0.01u)--(.2u,.25u)--(.1u,.15u)--cycle));\n"
"     block_width := (xpart urcorner block - xpart ulcorner block);\n"
"     \n"
"\t% scale last block to fit in the remaining gap\n"
"     scale_factor:=1.5*(laenge-cur)/block_width;\n"
"     forever:\n"
"           exitif scale_factor < 0;  % bruces stab at preventing endless loop at large scales\n"
"           exitif xpart ( (block rotated angle(-direction t of P) scaled scale_factor shifted (point t of P)) intersectiontimes old_block) < 0;\n"
"           scale_factor:=scale_factor-0.01;\n"
"     endfor;\n"
"     if scale_factor > 0:\n"
"       thclean block rotated angle(-direction t of P) scaled scale_factor shifted (point t of P);\n"
"       thdraw block rotated angle(-direction t of P) scaled scale_factor shifted (point t of P);\n"
"     fi;\n"
"enddef;\n"
"\n"
"\n"
"def l_wall_blocks_AUT (expr P) = \n"
"\n"
"  T:=identity;\n"
"  pickup PenC;\n"
"  laenge := arclength P;\n"
"\n"
"  path block;\n"
"  path old_block;\n"
"  \n"
"  cur := 0;\n"
"  t:= arctime cur of P;\n"
"  \n"
"  % draw first block\n"
"  old_block := ( (.7u,-.35u)--(.85u,0.01u)--(.4u,.5u)--(.1u,.3u)--(-.0u,-.0u) );\n"
"  block_width := (xpart urcorner old_block - xpart ulcorner old_block);\n"
"  old_block:=old_block rotated angle( thdir(P,0) ) shifted point t of P;\n"
"  thclean (old_block--cycle);\n"
"  thdraw old_block;\n"
"  \n"
"  \n"
"  cur := cur + block_width/2;\n"
"  t:= arctime cur of P;\n"
"  forever:\n"
"    % generate random block\n"
"    block := punked ( ( (.8u,-.35u)--(.85u,0.01u)--(.6u,.4u)--(.1u,.1u)--(-.0u,-.3u) )\n"
"          randomized (0.3u) )\n"
"           scaled (uniformdeviate(0.3)+.65)\n"
"          rotated (uniformdeviate(45)-15);\n"
"    % check width of block\n"
"    block_width := (xpart urcorner block - xpart ulcorner block);\n"
"    \n"
"    exitif cur > (laenge- 3.5*block_width/2);\n"
"    % find next position where the block fits in without intersecting the previous one\n"
"    forever:    \n"
"      exitif xpart ( ((block--cycle) rotated angle(direction t of P) shifted point t of P) intersectiontimes old_block) < 0;\n"
"      cur:=cur+0.01u;\n"
"      t:= arctime cur of P;\n"
"      exitif cur > (laenge- 3.5*block_width/2);\n"
"    endfor;\n"
"    exitif cur > (laenge- 3.5*block_width/2);\n"
"    \n"
"    old_block:= block rotated angle(direction t of P) shifted point t of P;\n"
"    thclean (old_block--cycle);\n"
"    thdraw old_block;\n"
"    \n"
"    \n"
"    cur := cur + block_width/2;\n"
"    t:= arctime cur of P;\n"
"  endfor;\n"
"  \n"
"    % generate last block\n"
"    t:= arctime laenge-eps of P;\n"
"    block := (( (-.15u,-.35u)--(.0u,.0u)--(-.45u,.5u)--(-.75u,.3u)--(-.85u,-.0u)) );\n"
"    block_width := (xpart urcorner block - xpart ulcorner block);\n"
"    % scale last block to fit in the remaining gap\n"
"    scale_factor:=(laenge-cur)/block_width;\n"
"    forever:\n"
"\t  exitif scale_factor < 0;\n"
"      exitif xpart ( ( (block) rotated angle (direction t of P) scaled scale_factor shifted (point t of P) ) intersectiontimes old_block) < 0;\n"
"      scale_factor:=scale_factor-0.001;\n"
"    endfor;\n"
"    if scale_factor > 0:\n"
"      thclean (block--cycle) rotated angle (direction t of P) scaled scale_factor shifted (point t of P);\n"
"      thdraw (block) rotated angle (direction t of P) scaled scale_factor shifted (point t of P);\n"
"    fi;\n"
"enddef;\n"
"\n"
"\n"
"\n"
"def l_wall_ice_AUT (expr P) = \n"
"  T:=identity;\n"
"  cas := 0;\n"
"  dlzka := arclength P;\n"
"  mojkrok:=adjust_step(dlzka, .6u);\n"
"  pickup PenC;\n"
"  p := (-.15u,0)--(.15u,0);\n"
"  q := p rotated 90 shifted (.25u,.0u);\n"
"  picture symbol,test_symbol;\n"
"  symbol:= image (\n"
"             thdraw p;\n"
"             thdraw q;\n"
"             );\n"
"  path bound,old_bound,test_bound;\n"
"  begingroup;\n"
"    interim bboxmargin:=0;\n"
"    bound := bbox (symbol);\n"
"  endgroup;\n"
"  t := arctime (cas + mojkrok/2) of P;\n"
"  thdraw symbol rotated angle(thdir(P,t)) shifted (point t of P + .25u * unitvector(thdir(P,t) rotated -90));\n"
"  old_bound:=bound rotated angle(thdir(P,t)) shifted (point t of P + .25u * unitvector(thdir(P,t) rotated -90));\n"
"\n"
"  forever:\n"
"    t := arctime (cas + mojkrok/2) of P;\n"
"    test_bound:= bound rotated angle(thdir(P,t)) shifted (point t of P + .25u * unitvector(thdir(P,t) rotated -90));\n"
"    if xpart ((old_bound) intersectiontimes (test_bound))<0:\n"
"      if xpart (P intersectiontimes (test_bound))<0:\n"
"        thdraw symbol rotated angle(thdir(P,t)) shifted (point t of P + .25u * unitvector(thdir(P,t) rotated -90));\n"
"        old_bound:=bound rotated angle(thdir(P,t)) shifted (point t of P + .25u * unitvector(thdir(P,t) rotated -90));\n"
"      fi;\n"
"    fi;\n"
"    cas := cas + mojkrok;\n"
"    exitif cas > dlzka - (2*mojkrok/3); % for rounding errors\n"
"  endfor;\n"
"  thdraw P;\n"
"enddef;\n"
"\n"
"\n"
"def l_wall_underlying_AUT (expr P) = \n"
"  T:=identity;\n"
"  pickup PenA;\n"
"  laenge:= arclength P;\n"
"  t1 := arctime (0.5u) of P;\n"
"  t2 := arctime (laenge-.5u) of P;\n"
"  thdraw (subpath (t1,t2) of P) dashed evenly scaled optical_zoom;\n"
"enddef;\n"
"\n"
"\n"
"def l_wall_overlying_AUT (expr P) = \n"
"  T:=identity;\n"
"  laenge:= arclength P;\n"
"  t1 := arctime (0.25u) of P;\n"
"  t2 := arctime (laenge-.25u) of P;\n"
"  t3 :=arctime (laenge) of P;\n"
"  pickup pensquare scaled (3.5*u/10);\n"
"  thdraw (subpath (t1,t2) of P) withcolor background;\n"
"    pickup PenA;\n"
"  thdraw subpath(0,t1) of P; \n"
"  thdraw subpath(t2,t3) of P;\n"
"  thdraw (subpath (t1,t2) of P) dashed dashpattern(on 2bp off 2bp on .5bp off 2bp on 2bp) scaled optical_zoom;\n"
"enddef;\n"
"\n"
"def l_wall_moonmilk_AUT (expr P) = \n"
"  T:=identity;\n"
"  laenge:= arclength P;\n"
"  symsize:=adjust_step(laenge,0.8u);\n"
"  circle_width:=symsize/2;\n"
"  cur:=(symsize-circle_width)/2;\n"
"  pickup PenC;\n"
"  forever:\n"
"    t1 := arctime (cur) of P;\n"
"    t2 := arctime (cur + circle_width) of P;\n"
"    thdraw (point t1 of P){dir (angle(thdir(P,t1)) + 90)} ..\n"
"           {dir (angle(thdir(P,t2)) - 90)}(point t2 of P);\n"
"    cur := cur + symsize;\n"
"    exitif cur > laenge + (symsize / 3); % for rounding errors\n"
"  endfor;\n"
"  pickup PenA;\n"
"  thdraw P;\n"
"enddef;\n"
"\n"
"def l_wall_flowstone_AUT (expr P) = \n"
"  T:=identity;\n"
"  laenge:= arclength P;\n"
"  symsize:=adjust_step(laenge,0.8u);\n"
"  circle_width:=symsize/2;\n"
"  cur:=(symsize-circle_width)/2;\n"
"  pickup PenC;\n"
"  forever:\n"
"    t1 := arctime (cur) of P;\n"
"    t2 := arctime (cur + circle_width) of P;\n"
"    thdraw (point t1 of P){dir (angle(thdir(P,t1)) + 90)} ..\n"
"           {dir (angle(thdir(P,t2)) - 90)}(point t2 of P);\n"
"    thfill (point t1 of P){dir (angle(thdir(P,t1)) + 90)} ..\n"
"           {dir (angle(thdir(P,t2)) - 90)}(point t2 of P) --\n"
"           (point t1 of P)--cycle;\n"
"    cur := cur + symsize;\n"
"    exitif cur > laenge + (symsize / 3); % for rounding errors\n"
"  endfor;\n"
"  pickup PenA;\n"
"  thdraw P;\n"
"enddef;\n"
"\n"
"def l_pit_AUT (expr P) =\n"
"  T:=identity;\n"
"  laenge:= arclength P;\n"
"  symsize:=adjust_step(laenge,0.5u);\n"
"  triangle_width:=symsize/2;\n"
"  cur:=(symsize-triangle_width)/2;\n"
"  pickup PenC;\n"
"  forever:\n"
"    t1 := arctime (cur) of P;\n"
"    t  := arctime (cur + triangle_width/2) of P;\n"
"    t2 := arctime (cur + triangle_width) of P;\n"
"    if ATTR__height >= 10:\n"
"      thfill (subpath (t1,t2) of P) -- \n"
"        ((point t of P) + symsize/2 * unitvector(thdir(P,t) rotated 90)) -- \n"
"        cycle;\n"
"    else:\n"
"      thclean (subpath (t1,t2) of P) -- \n"
"        ((point t of P) + symsize/2 * unitvector(thdir(P,t) rotated 90)) -- \n"
"        cycle;\n"
"      thdraw (point t2 of P) --((point t of P) + symsize/2 * unitvector(thdir(P,t) rotated 90)) -- \n"
"        (point t1 of P);\n"
"    fi;\n"
"    cur := cur + symsize;\n"
"    exitif cur > laenge - (1*symsize/3); % for rounding errors\n"
"    t1:=arctime (cur) of P;\n"
"  endfor;\n"
"  thdraw P;\n"
"enddef;\n"
"\n"
"\n"
"let l_overhang_AUT = l_pit_AUT;\n"
"\n"
"let l_floorstep_AUT = l_floorstep_UIS;\n"
"\n"
"let l_contour_AUT =l_contour_SKBB;\n"
"\n"
"def l_flowstone_AUT (expr P) = \n"
"  T:=identity;\n"
"  pickup PenC;\n"
"  thdraw P dashed evenly scaled optical_zoom;\n"
"enddef;\n"
"\n"
"def l_survey_cave_AUT (expr P) =\n"
"  T:=identity;\n"
"  pair zz[];\n"
"  pickup PenD;\n"
"  thdraw P;\n"
"enddef;\n"
"\n"
"%% points\n"
"\n"
"def p_stalactite_AUT(expr pos,theta,sc,al) =\n"
"    pickup PenC;\n"
"    if ATTR__elevation:\n"
"      U:=(.15u, .4u);\n"
"      T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"      thdraw (0,-.4u) -- (0,.15u) -- (-.15u,.4u);\n"
"      thdraw (0,.15u) -- (.15u,.4u);\n"
"    else:\n"
"      U:=(.175u, .175u);\n"
"      T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"      thclean fullcircle scaled 0.35u;\n"
"      thdraw fullcircle scaled 0.35u;\n"
"    fi;\n"
"enddef;\n"
"\n"
"let p_icestalactite_AUT = p_stalactite_AUT;\n"
"\n"
"def p_stalagmite_AUT(expr pos,theta,sc,al) =\n"
"    pickup PenC;\n"
"    if ATTR__elevation:\n"
"      U:=(.15u,.4u);\n"
"      T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"      thdraw (0,.4u) -- (0,-.15u) -- (-.15u,-.4u);\n"
"      thdraw (0,-.15u) -- (.15u,-.4u);\n"
"    else:\n"
"      U:=(.15u,.15u);\n"
"      T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"      thfill fullcircle scaled 0.3u;\n"
"    fi;\n"
"enddef;\n"
"\n"
"let p_icestalagmite_AUT = p_stalagmite_AUT;\n"
"\n"
"def p_pillar_AUT(expr pos,theta,sc,al) =\n"
"    pickup PenC;\n"
"    if ATTR__elevation:\n"
"      U:=(.15u,.4u);\n"
"      T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"      thdraw (0,.15u)--(0,-.15u);\n"
"      thdraw (-.15u,-.4u)--(0,-.15u)--(.15u,-.4u);\n"
"      thdraw (-.15u,.4u)--(0,.15u)--(.15u,.4u);\n"
"    else:\n"
"      U:=(.225u,.225u);\n"
"      T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"      thclean fullcircle scaled 0.45u;\n"
"      thdraw fullcircle scaled 0.45u;\n"
"      thfill fullcircle scaled 0.3u;\n"
"    fi;\n"
"enddef;\n"
"\n"
"let p_icepillar_AUT = p_pillar_AUT;\n"
"\n"
"def p_crystal_AUT (expr pos,theta,sc,al)=\n"
"    U:=(.35u,.35u);\n"
"    T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"   \n"
"    pickup PenC;\n"
"    p := ((-.35*u,0)--(.35*u,0));\n"
"    thdraw p;\n"
"    thdraw p rotated (45);\n"
"    thdraw p rotated (90);\n"
"    thdraw p rotated (135);\n"
"    \n"
"    thdrawoptions();\n"
"\n"
"enddef;\n"
"\n"
"def p_spring_AUT (expr pos,theta,sc,al)=\n"
"  U:=(.3u,.2u);\n"
"  T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"  pickup PenC;\n"
"  thdraw (-.3u,.1u)..(0,-.1u)..(.3u,.1u);\n"
"enddef;\n"
"\n"
"\n"
"def p_sink_AUT (expr pos,theta,sc,al)=\n"
"  U:=(.3u,.2u);\n"
"  T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"  pickup PenC;\n"
"  thdraw (-.3u,-.1u)..(0,.1u)..(.3u,-.1u);\n"
"enddef;\n"
"\n"
"def p_breakdownchoke_AUT (expr pos,theta,sc,al)=\n"
"    U:=(.4u,.4u);\n"
"    T:=identity rotated -theta aligned al rotated theta scaled sc shifted pos;\n"
"    pickup PenC;\n"
"    thclean (-.4u,-.4u)--(.4u,-.4u)--(.4u,.4u)--(-.4u,.4u)--cycle;\n"
"    thdraw (-.4u,-.4u)--(.4u,-.4u)--(.4u,.4u)--(-.4u,.4u)--cycle;\n"
"    thdraw (-.21u,.305u)--(.0u,-.305u)--(.21u,.305u);\n"
"enddef;\n"
"\n"
"def p_sand_AUT (expr pos,theta,sc,al)=\n"
"    U:=(.2u,.2u);\n"
"    T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"    pickup PenC;\n"
"    p:= origin -- (0.01u,0.01u);\n"
"    for i=-0.1u step 0.2u until .15u:\n"
"        for j=-0.1u step 0.2u until .15u:\n"
"          thdraw p rotated uniformdeviate(360) \n"
"           shifted ((i,j) randomized 0.09u);\n"
"        endfor;\n"
"    endfor;\n"
"    thdrawoptions();\n"
"enddef;\n"
"\n"
"let p_clay_AUT  = p_sand_AUT;\n"
"\n"
"def p_pebbles_AUT (expr pos,theta,sc,al)=\n"
"    U:=(.4u,.4u);\n"
"    T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"    pickup PenC;\n"
"    path qq;\n"
"    for i=-0.15u step 0.3u until .2u:\n"
"        for j=-0.15u step 0.3u until .2u:\n"
"          qq := (superellipse((.1u,0),(0,.05u),(-.1u,0),(0,.-.05u),.75))\n"
"             randomized (u/45)\n"
"             scaled (uniformdeviate(0.4)+.55)\n"
"             rotated uniformdeviate(360) \n"
"             shifted ((i,j) randomized 0.15u);\n"
"           thdraw qq;\n"
"        endfor;\n"
"    endfor;\n"
"enddef;\n"
"\n"
"def p_debris_AUT (expr pos,theta,sc,al)=\n"
"    U:=(.5u,.5u);\n"
"    T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"    pickup PenC;\n"
"    path block,q;\n"
"    block :=  ((-.15u,-.15u)--(.15u,-.15u)--(.3u,0.01u)--(.15u,.15u)--(-.15u,.15u)--cycle) ;\n"
"    \n"
"    q:= (punked (block randomized (0.15u))) rotated uniformdeviate(360) scaled (uniformdeviate(0.3)+0.3) shifted (0.0u,0.15u);\n"
"    thclean q; thdraw q;\n"
"    \n"
"    q:= (punked (block randomized (0.15u))) rotated uniformdeviate(360) scaled (uniformdeviate(0.5)+0.7) shifted (-0.15u,-0.15u);\n"
"    thclean q; thdraw q;\n"
"\n"
"    q:=  (punked (block randomized (0.15u))) rotated uniformdeviate(360) shifted (0.15u,-0.15u);\n"
"    thclean q; thdraw q;\n"
"    \n"
"enddef;\n"
"\n"
"def p_blocks_AUT (expr pos,theta,sc,al)=\n"
"    U:=(u,u);\n"
"    T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"    pickup PenC;\n"
"\n"
"    path block,q;\n"
"    block :=  ((-.25u,-.25u)--(.25u,-.25u)--(.5u,0.01u)--(.25u,.25u)--(-.25u,.25u)--cycle) ;\n"
"    \n"
"    q:= (punked (block randomized (0.3u))) rotated uniformdeviate(360) scaled (uniformdeviate(0.3)+0.3) shifted (0.0u,0.25u);\n"
"    thclean q; thdraw q;\n"
"    \n"
"    q:= (punked (block randomized (0.3u))) rotated uniformdeviate(360) scaled (uniformdeviate(0.5)+0.7) shifted (-0.25u,-0.25u);\n"
"    thclean q; thdraw q;\n"
"\n"
"    q:=  (punked (block randomized (0.3u))) rotated uniformdeviate(360) shifted (0.25u,-0.25u);\n"
"    thclean q; thdraw q;\n"
"    \n"
"enddef;\n"
"\n"
"def p_water_AUT (expr pos,theta,sc,al)=\n"
"    U:=(.425u,.3u);\n"
"    T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"    pickup PenD;\n"
"    p:=fullcircle xscaled (.85u) yscaled (.6u);\n"
"    thfill p withcolor col_water_bg;\n"
"    thfill p withpattern pattern_water_AUT;\n"
"    thdraw p;\n"
"enddef;\n"
"\n"
"def p_ice_AUT (expr pos,theta,sc,al)=\n"
"    U:=(.6u,.4u);\n"
"    T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"    pickup PenC;\n"
"    p:=(-.15u,.0u) -- (0.15u,.0u);\n"
"    thdraw p rotated 90;\n"
"    thdraw p shifted (0.45u,.0u);\n"
"    thdraw p shifted (-0.45u,.0u);\n"
"    \n"
"    thdraw p rotated 90 shifted (-0.45u,0.25u);\n"
"    thdraw p shifted (0u,0.25u);\n"
"    thdraw p rotated 90 shifted (0.45u,.25u);\n"
"enddef;\n"
"\n"
"def p_entrance_AUT (expr pos,theta,sc,al)=\n"
"    U:=(.3u,.75u);\n"
"    T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"    path slice;\n"
"    for i= -0.5 step 0.01 until 0.5:\n"
"      slice:= (-.3u*(0.5-i),1.5*i*u)--(0,.75u)--(.3u*(0.5-i),1.5i*u)--cycle;\n"
"      thfill slice withcolor (min(0.95,0.5-1.75i),min(0.95,.5-1.75i),min(0.95,.5-1.75i));\n"
"    endfor;\n"
"    thdraw ((-.3u,-0.75u)--(0,.75u)--(.3u,-0.75u)--cycle);\n"
"enddef;\n"
"    \n"
"def p_gradient_AUT (expr pos,theta,sc,al)=\n"
"    U:=(.15u,u);\n"
"    T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"    pickup PenC;\n"
"    thdraw (0,-0.5u)--(0,0.5u);\n"
"    p:=(-.15u,.3u)--(0,0.7u)--(.15u,.3u)--cycle;\n"
"    thfill p;\n"
"    thdraw p;\n"
"enddef;\n"
"\n"
"def p_airdraught_AUT (expr pos,theta,sc,al)=\n"
"  U:=(.2u,u);\n"
"  T:=identity aligned al rotated theta scaled 1 shifted pos;\n"
"  pickup PenC;\n"
"  thdraw (0,.5u)--(0,-0.8u);\n"
"\tp:=(-.2u,.2u)--(0,.55u)--(.2u,.2u)--cycle;\n"
"\tthfill p;\n"
"\tfor i:=1 upto round(3+2*mlog(sc)/mlog 2):\n"
"\t  thdraw (0,-(1-0.2i)*u)--(.2u,-(1-0.2(i-1))*u);\n"
"\t  thdraw (0,-(1-0.2i)*u)--(-.2u,-(1-0.2(i-1))*u);\n"
"\tendfor;\n"
"enddef;\n"
"\n"
"def p_station_temporary_AUT (expr pos)=\n"
"    T:=identity shifted pos;\n"
"    pickup PenD;\n"
"    thclean fullcircle scaled 0.15u;\n"
"    thdraw fullcircle scaled 0.15u;\n"
"enddef;\n"
"\n"
"let p_station_painted_AUT = p_station_temporary_AUT ;\n"
"let p_station_fixed_AUT = p_station_temporary_AUT ;\n"
"\n"
"def p_claychoke_AUT (expr pos,theta,sc,al)=\n"
"    U:=(.4u,.4u);\n"
"    T:=identity rotated -theta aligned al rotated theta scaled sc shifted pos;\n"
"    pickup PenC;\n"
"    thclean (-.4u,-.4u)--(.4u,-.4u)--(.4u,.4u)--(-.4u,.4u)--cycle;\n"
"    thdraw (-.4u,-.4u)--(.4u,-.4u)--(.4u,.4u)--(-.4u,.4u)--cycle;\n"
"    thdraw (-.15u,.3u)--(-.15u,-.25u)--(.15u,-.25u);\n"
"enddef;\n"
"\n"
"def p_claytree_AUT (expr pos,theta,sc,al)=\n"
"    U:=(.55u,.6u);\n"
"    T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"    pickup PenC;\n"
"    p:= (-.15u,.15u)--(.0u,.6u)--(.15u,.15u);\n"
"    thdraw p ;\n"
"    thdraw p shifted (-.4u,-.3u);\n"
"    thdraw p shifted (.4u,-.2u) ;\n"
"enddef;\n"
"\n"
"\n\n\n%%%%% ENDINPUT uAUT %%%%%\n\n\n"
"\n"
"\n\n\n%%%%% INPUT thTrans %%%%%\n\n\n"
"% default translations\n"
"\n"
"let p_station_fixed = p_station_fixed_ASF;\n"
"let p_station_painted = p_station_painted_SKBB;\n"
"let p_station_natural = p_station_natural_ASF;              \n"
"let p_station_temporary = p_station_temporary_ASF;\n"
"\n"
"let p_waterflow_paleo = p_waterflow_paleo_UIS;\n"
"let p_waterflow_permanent = p_waterflow_permanent_UIS;\n"
"let p_waterflow_intermittent = p_waterflow_intermittent_UIS;\n"
"\n"
"let p_stalactite = p_stalactite_UIS;\n"
"let p_stalagmite = p_stalagmite_UIS;\n"
"let p_pillar = p_pillar_UIS;\n"
"let p_icestalactite = p_icestalactite_AUT;\n"
"let p_icestalagmite = p_icestalagmite_AUT;\n"
"let p_icepillar = p_icepillar_AUT;\n"
"let p_curtain = p_curtain_UIS;\n"
"let p_helictite = p_helictite_UIS;\n"
"let p_sodastraw = p_sodastraw_UIS;\n"
"let p_crystal = p_crystal_UIS;\n"
"let p_flowstone = p_flowstone_UIS;\n"
"let p_moonmilk = p_moonmilk_UIS;\n"
"let p_wallcalcite = p_wallcalcite_UIS;\n"
"let p_popcorn = p_popcorn_UIS;\n"
"let p_disk = p_disk_UIS;\n"
"let p_gypsum = p_gypsum_NSS;\n"
"let p_aragonite = p_aragonite_NSS;\n"
"let p_cavepearl = p_cavepearl_SKBB;\n"
"let p_gypsumflower = p_gypsumflower_NSS;\n"
"let p_rimstonepool = p_rimstonepool_ASF;\n"
"let p_rimstonedam = p_rimstonedam_ASF;\n"
"let p_anastomosis = p_anastomosis_UIS;\n"
"let p_karren = p_karren_UIS;\n"
"let p_scallop = p_scallop_UIS;\n"
"let p_flute = p_flute_UIS;\n"
"let p_raft = p_raft_NSS;\n"
"let p_raftcone = p_raftcone_NSS;\n"
"let p_spring = p_spring_SKBB;\n"
"let p_sink = p_sink_SKBB;\n"
"let p_narrowend = p_narrowend_UIS;\n"
"let p_lowend = p_lowend_UIS;\n"
"let p_flowstonechoke = p_flowstonechoke_NSS;\n"
"let p_breakdownchoke = p_breakdownchoke_NSS;\n"
"let p_claychoke = p_claychoke_AUT;\n"
"let p_claytree = p_claytree_AUT;\n"
"let p_bedrock = p_bedrock_ASF;\n"
"let p_clay = p_clay_SKBB;                        \n"
"let p_sand = p_sand_UIS;\n"
"let p_pebbles = p_pebbles_UIS;\n"
"let p_debris = p_debris_UIS;\n"
"let p_blocks = p_blocks_UIS;\n"
"let p_water = p_water_UIS;\n"
"let p_ice = p_ice_UIS;\n"
"let p_snow = p_snow_SKBB;\n"
"let p_archeomaterial = p_archeomaterial_UIS;\n"
"let p_paleomaterial = p_paleomaterial_UIS;\n"
"let p_guano = p_guano_UIS;\n"
"let p_vegetabledebris = p_vegetabledebris_ASF;\n"
"let p_root = p_root_ASF;\n"
"let p_entrance = p_entrance_UIS;\n"
"let p_gradient = p_gradient_UIS;\n"
"let p_rope = p_rope_SKBB;          \n"
"let p_fixedladder = p_fixedladder_SKBB;   \n"
"let p_ropeladder = p_ropeladder_SKBB;    \n"
"let p_steps = p_steps_SKBB;         \n"
"let p_bridge = p_bridge_SKBB;        \n"
"let p_traverse = p_traverse_SKBB;\n"
"let p_anchor = p_anchor_SKBB;\n"
"let p_camp = p_camp_SKBB;\n"
"let p_dig = p_dig_UIS;\n"
"let p_noequipment = p_noequipment_SKBB;\n"
"let p_sectionarrow = p_sectionarrow_SKBB;\n"
"let p_continuation = p_continuation_UIS;\n"
"let p_airdraught = p_airdraught_UIS;\n"
"let p_airdraught_winter = p_airdraught_winter_UIS;\n"
"let p_airdraught_summer = p_airdraught_summer_UIS;\n"
"let p_station = p_station_SKBB;\n"
"let p_handrail = p_handrail_SKBB;\n"
"let p_viaferrata = p_viaferrata_SKBB;\n"
"let p_stalactites = p_stalactites_UIS;\n"
"let p_stalagmites = p_stalagmites_UIS;\n"
"let p_pillars = p_pillars_UIS;\n"
"\n"
"let l_wall_bedrock = l_wall_bedrock_UIS;\n"
"let l_wall_sand = l_wall_sand_SKBB;\n"
"let l_wall_clay = l_wall_clay_SKBB;\n"
"let l_wall_pebbles = l_wall_pebbles_SKBB;\n"
"let l_wall_debris = l_wall_debris_SKBB;\n"
"let l_wall_blocks = l_wall_blocks_SKBB;\n"
"let l_wall_ice = l_wall_ice_SKBB;\n"
"let l_wall_underlying = l_wall_underlying_UIS;\n"
"let l_wall_unsurveyed = l_wall_unsurveyed_SKBB;\n"
"let l_wall_presumed = l_wall_presumed_UIS;\n"
"%let l_wall_invisible = l_wall_invisible;\n"
"let l_wall_pit = l_wall_pit_AUT;\n"
"let l_wall_overlying = l_wall_overlying_AUT;\n"
"let l_wall_flowstone = l_wall_flowstone_AUT;\n"
"let l_wall_moonmilk = l_wall_moonmilk_AUT;\n"
"\n"
"let l_waterflow_permanent = l_waterflow_permanent_UIS;\n"
"let l_waterflow_intermittent = l_waterflow_intermittent_SKBB;\n"
"let l_waterflow_conjectural = l_waterflow_conjectural_SKBB;\n"
"\n"
"let l_border_visible = l_border_visible_SKBB;\n"
"let l_border_temporary = l_border_temporary_SKBB;\n"
"let l_border_presumed = l_border_presumed_SKBB;\n"
"%let l_border_invisible = l_border_invisible;\n"
"\n"
"let l_floorstep = l_floorstep_UIS;\n"
"let l_pit = l_pit_UIS;\n"
"let l_ceilingstep = l_ceilingstep_SKBB;\n"
"let l_chimney = l_chimney_UIS;\n"
"let l_overhang = l_overhang_SKBB;\n"
"let l_slope = l_slope_SKBB;\n"
"let l_ceilingmeander = l_ceilingmeander_SKBB;\n"
"let l_floormeander = l_floormeander_SKBB;\n"
"let l_contour = l_contour_SKBB;\n"
"let l_rockborder = l_rockborder_UIS;\n"
"let l_rockedge = l_rockedge_UIS;\n"
"let l_flowstone = l_flowstone_UIS;\n"
"let l_moonmilk = l_moonmilk_UIS;\n"
"let l_section = l_section_SKBB;\n"
"let l_survey_cave = l_survey_cave_SKBB;\n"
"let l_survey_surface = l_survey_surface_SKBB;\n"
"let l_arrow = l_arrow_SKBB;\n"
"let l_gradient = l_gradient_UIS;\n"
"let l_mapconnection = l_mapconnection_SKBB;\n"
"let l_handrail = l_handrail_SKBB;\n"
"let l_steps = l_steps_SKBB;\n"
"let l_fixedladder = l_fixedladder_SKBB;\n"
"let l_ropeladder = l_ropeladder_SKBB;\n"
"let l_rope = l_rope_SKBB;\n"
"let l_viaferrata = l_viaferrata_SKBB;\n"
"\n"
"let a_water = a_water_UIS;\n"
"let a_sump = a_sump_UIS;\n"
"let a_sand = a_sand_UIS;\n"
"let a_debris = a_debris_SKBB;\n"
"let a_blocks = a_blocks_SKBB;\n"
"let a_snow = a_snow_SKBB;\n"
"let a_ice = a_ice_SKBB;\n"
"let a_pebbles = a_pebbles_SKBB;\n"
"let a_clay = a_clay_SKBB;\n"
"let a_bedrock = a_bedrock_SKBB;\n"
"let a_flowstone = a_flowstone_ASF;\n"
"let a_moonmilk = a_moonmilk_SKBB;\n"
"let a_dimensions = a_dimensions_SKBB;\n"
"\n"
"let s_northarrow = s_northarrow_SKBB;\n"
"let s_scalebar = s_scalebar_SKBB;\n"
"let s_hgrid = s_hgrid_SM;\n"
"let s_vgrid = s_vgrid_SM;\n"
"\n\n\n%%%%% ENDINPUT thTrans %%%%%\n\n\n"
"\n"
"nonstopmode;\n"
"initsymbol(\"s_hgrid_SM\");\n"
"initsymbol(\"s_northarrow_SKBB\");\n"
"initsymbol(\"s_scalebar_SKBB\");\n"
"initsymbol(\"s_scalebar_SM\");\n"
"initsymbol(\"s_vgrid_SM\");\n"
"initsymbol(\"p_airdraught_AUT\");\n"
"initsymbol(\"p_airdraught_UIS\");\n"
"initsymbol(\"p_airdraught_summer_UIS\");\n"
"initsymbol(\"p_airdraught_winter_UIS\");\n"
"initsymbol(\"p_anastomosis_UIS\");\n"
"initsymbol(\"p_anchor_SKBB\");\n"
"initsymbol(\"p_aragonite_NSS\");\n"
"initsymbol(\"p_archeomaterial_UIS\");\n"
"initsymbol(\"p_bedrock_ASF\");\n"
"initsymbol(\"p_blocks_AUT\");\n"
"initsymbol(\"p_blocks_UIS\");\n"
"initsymbol(\"p_breakdownchoke_AUT\");\n"
"initsymbol(\"p_breakdownchoke_NSS\");\n"
"initsymbol(\"p_bridge_SKBB\");\n"
"initsymbol(\"p_camp_SKBB\");\n"
"initsymbol(\"p_cavepearl_SKBB\");\n"
"initsymbol(\"p_clay_AUT\");\n"
"initsymbol(\"p_clay_SKBB\");\n"
"initsymbol(\"p_claychoke_AUT\");\n"
"initsymbol(\"p_claytree_AUT\");\n"
"initsymbol(\"p_continuation_UIS\");\n"
"initsymbol(\"p_crystal_AUT\");\n"
"initsymbol(\"p_crystal_UIS\");\n"
"initsymbol(\"p_curtain_UIS\");\n"
"initsymbol(\"p_debris_AUT\");\n"
"initsymbol(\"p_debris_UIS\");\n"
"initsymbol(\"p_dig_UIS\");\n"
"initsymbol(\"p_disk_UIS\");\n"
"initsymbol(\"p_entrance_AUT\");\n"
"initsymbol(\"p_entrance_UIS\");\n"
"initsymbol(\"p_fixedladder_SKBB\");\n"
"initsymbol(\"p_flowstone_UIS\");\n"
"initsymbol(\"p_flowstonechoke_NSS\");\n"
"initsymbol(\"p_flute_UIS\");\n"
"initsymbol(\"p_gradient_AUT\");\n"
"initsymbol(\"p_gradient_BCRA\");\n"
"initsymbol(\"p_gradient_NSS\");\n"
"initsymbol(\"p_gradient_SKBB\");\n"
"initsymbol(\"p_gradient_UIS\");\n"
"initsymbol(\"p_guano_UIS\");\n"
"initsymbol(\"p_gypsum_NSS\");\n"
"initsymbol(\"p_gypsumflower_NSS\");\n"
"initsymbol(\"p_handrail_SKBB\");\n"
"initsymbol(\"p_helictite_UIS\");\n"
"initsymbol(\"p_ice_AUT\");\n"
"initsymbol(\"p_ice_UIS\");\n"
"initsymbol(\"p_icepillar_AUT\");\n"
"initsymbol(\"p_icestalactite_AUT\");\n"
"initsymbol(\"p_icestalagmite_AUT\");\n"
"initsymbol(\"p_karren_UIS\");\n"
"initsymbol(\"p_lowend_NSS\");\n"
"initsymbol(\"p_lowend_UIS\");\n"
"initsymbol(\"p_moonmilk_UIS\");\n"
"initsymbol(\"p_narrowend_UIS\");\n"
"initsymbol(\"p_noequipment_SKBB\");\n"
"initsymbol(\"p_paleomaterial_UIS\");\n"
"initsymbol(\"p_pebbles_AUT\");\n"
"initsymbol(\"p_pebbles_UIS\");\n"
"initsymbol(\"p_pillar_AUT\");\n"
"initsymbol(\"p_pillar_UIS\");\n"
"initsymbol(\"p_pillars_UIS\");\n"
"initsymbol(\"p_popcorn_UIS\");\n"
"initsymbol(\"p_raft_NSS\");\n"
"initsymbol(\"p_raftcone_NSS\");\n"
"initsymbol(\"p_rimstonedam_ASF\");\n"
"initsymbol(\"p_rimstonepool_ASF\");\n"
"initsymbol(\"p_root_ASF\");\n"
"initsymbol(\"p_rope_SKBB\");\n"
"initsymbol(\"p_ropeladder_SKBB\");\n"
"initsymbol(\"p_sand_AUT\");\n"
"initsymbol(\"p_sand_UIS\");\n"
"initsymbol(\"p_scallop_UIS\");\n"
"initsymbol(\"p_sink_AUT\");\n"
"initsymbol(\"p_sink_SKBB\");\n"
"initsymbol(\"p_snow_SKBB\");\n"
"initsymbol(\"p_sodastraw_UIS\");\n"
"initsymbol(\"p_spring_AUT\");\n"
"initsymbol(\"p_spring_SKBB\");\n"
"initsymbol(\"p_stalactite_AUT\");\n"
"initsymbol(\"p_stalactite_UIS\");\n"
"initsymbol(\"p_stalactites_UIS\");\n"
"initsymbol(\"p_stalagmite_AUT\");\n"
"initsymbol(\"p_stalagmite_UIS\");\n"
"initsymbol(\"p_stalagmites_UIS\");\n"
"initsymbol(\"p_station_SKBB\");\n"
"initsymbol(\"p_station_fixed_ASF\");\n"
"initsymbol(\"p_station_fixed_AUT\");\n"
"initsymbol(\"p_station_natural_ASF\");\n"
"initsymbol(\"p_station_painted_AUT\");\n"
"initsymbol(\"p_station_painted_SKBB\");\n"
"initsymbol(\"p_station_temporary_ASF\");\n"
"initsymbol(\"p_station_temporary_AUT\");\n"
"initsymbol(\"p_station_temporary_SKBB\");\n"
"initsymbol(\"p_steps_SKBB\");\n"
"initsymbol(\"p_traverse_SKBB\");\n"
"initsymbol(\"p_vegetabledebris_ASF\");\n"
"initsymbol(\"p_viaferrata_SKBB\");\n"
"initsymbol(\"p_wallcalcite_UIS\");\n"
"initsymbol(\"p_water_AUT\");\n"
"initsymbol(\"p_water_UIS\");\n"
"initsymbol(\"p_waterflow_intermittent_UIS\");\n"
"initsymbol(\"p_waterflow_paleo_UIS\");\n"
"initsymbol(\"p_waterflow_permanent_UIS\");\n"
"initsymbol(\"l_arrow_SKBB\");\n"
"initsymbol(\"l_border_presumed_SKBB\");\n"
"initsymbol(\"l_border_temporary_SKBB\");\n"
"initsymbol(\"l_border_visible_SKBB\");\n"
"initsymbol(\"l_ceilingmeander_NZSS\");\n"
"initsymbol(\"l_ceilingmeander_SKBB\");\n"
"initsymbol(\"l_ceilingmeander_UIS\");\n"
"initsymbol(\"l_ceilingstep_NZSS\");\n"
"initsymbol(\"l_ceilingstep_SKBB\");\n"
"initsymbol(\"l_ceilingstep_UIS\");\n"
"initsymbol(\"l_chimney_NZSS\");\n"
"initsymbol(\"l_chimney_UIS\");\n"
"initsymbol(\"l_contour_AUT\");\n"
"initsymbol(\"l_contour_SKBB\");\n"
"initsymbol(\"l_contour_UIS\");\n"
"initsymbol(\"l_fixedladder_SKBB\");\n"
"initsymbol(\"l_floormeander_SKBB\");\n"
"initsymbol(\"l_floorstep_AUT\");\n"
"initsymbol(\"l_floorstep_UIS\");\n"
"initsymbol(\"l_flowstone_AUT\");\n"
"initsymbol(\"l_flowstone_UIS\");\n"
"initsymbol(\"l_gradient_BCRA\");\n"
"initsymbol(\"l_gradient_UIS\");\n"
"initsymbol(\"l_handrail_SKBB\");\n"
"initsymbol(\"l_mapconnection_SKBB\");\n"
"initsymbol(\"l_moonmilk_UIS\");\n"
"initsymbol(\"l_overhang_AUT\");\n"
"initsymbol(\"l_overhang_SKBB\");\n"
"initsymbol(\"l_pit_AUT\");\n"
"initsymbol(\"l_pit_UIS\");\n"
"initsymbol(\"l_rockborder_UIS\");\n"
"initsymbol(\"l_rockedge_UIS\");\n"
"initsymbol(\"l_rope_SKBB\");\n"
"initsymbol(\"l_ropeladder_SKBB\");\n"
"initsymbol(\"l_section_SKBB\");\n"
"initsymbol(\"l_slope_BCRA\");\n"
"initsymbol(\"l_slope_SKBB\");\n"
"initsymbol(\"l_steps_SKBB\");\n"
"initsymbol(\"l_survey_cave_AUT\");\n"
"initsymbol(\"l_survey_cave_SKBB\");\n"
"initsymbol(\"l_survey_cave_UIS\");\n"
"initsymbol(\"l_survey_surface_SKBB\");\n"
"initsymbol(\"l_viaferrata_SKBB\");\n"
"initsymbol(\"l_wall_bedrock_UIS\");\n"
"initsymbol(\"l_wall_blocks_AUT\");\n"
"initsymbol(\"l_wall_blocks_SKBB\");\n"
"initsymbol(\"l_wall_clay_AUT\");\n"
"initsymbol(\"l_wall_clay_SKBB\");\n"
"initsymbol(\"l_wall_debris_AUT\");\n"
"initsymbol(\"l_wall_debris_SKBB\");\n"
"initsymbol(\"l_wall_flowstone_AUT\");\n"
"initsymbol(\"l_wall_ice_AUT\");\n"
"initsymbol(\"l_wall_ice_SKBB\");\n"
"initsymbol(\"l_wall_moonmilk_AUT\");\n"
"initsymbol(\"l_wall_overlying_AUT\");\n"
"initsymbol(\"l_wall_pebbles_AUT\");\n"
"initsymbol(\"l_wall_pebbles_SKBB\");\n"
"initsymbol(\"l_wall_pit_AUT\");\n"
"initsymbol(\"l_wall_presumed_NZSS\");\n"
"initsymbol(\"l_wall_presumed_UIS\");\n"
"initsymbol(\"l_wall_sand_AUT\");\n"
"initsymbol(\"l_wall_sand_SKBB\");\n"
"initsymbol(\"l_wall_underlying_AUT\");\n"
"initsymbol(\"l_wall_underlying_UIS\");\n"
"initsymbol(\"l_wall_unsurveyed_SKBB\");\n"
"initsymbol(\"l_waterflow_conjectural_SKBB\");\n"
"initsymbol(\"l_waterflow_intermittent_SKBB\");\n"
"initsymbol(\"l_waterflow_permanent_UIS\");\n"
"initsymbol(\"a_bedrock_SKBB\");\n"
"initsymbol(\"a_blocks_AUT\");\n"
"initsymbol(\"a_blocks_SKBB\");\n"
"initsymbol(\"a_clay_AUT\");\n"
"initsymbol(\"a_clay_SKBB\");\n"
"initsymbol(\"a_debris_AUT\");\n"
"initsymbol(\"a_debris_SKBB\");\n"
"initsymbol(\"a_debris_UIS\");\n"
"initsymbol(\"a_dimensions_SKBB\");\n"
"initsymbol(\"a_flowstone_ASF\");\n"
"initsymbol(\"a_ice_AUT\");\n"
"initsymbol(\"a_ice_SKBB\");\n"
"initsymbol(\"a_moonmilk_SKBB\");\n"
"initsymbol(\"a_pebbles_AUT\");\n"
"initsymbol(\"a_pebbles_SKBB\");\n"
"initsymbol(\"a_sand_AUT\");\n"
"initsymbol(\"a_sand_UIS\");\n"
"initsymbol(\"a_snow_AUT\");\n"
"initsymbol(\"a_snow_SKBB\");\n"
"initsymbol(\"a_sump_AUT\");\n"
"initsymbol(\"a_sump_SKBB\");\n"
"initsymbol(\"a_sump_UIS\");\n"
"initsymbol(\"a_water_AUT\");\n"
"initsymbol(\"a_water_SKBB\");\n"
"initsymbol(\"a_water_UIS\");\n"
;

#else

const char * thmpost_library = "input therion;";

#endif

